[
{
	"uri": "https://blog.dexiang.me/zh-tw/archive/",
	"title": "Archive",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": "archive page\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/iterm2/",
	"title": "iTerm2",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/oh-my-zsh/",
	"title": "oh-my-zsh",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/powerlevel9k/",
	"title": "powerlevel9k",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/categories/tech/",
	"title": "tech",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/",
	"title": "Technologies",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/zsh/",
	"title": "zsh",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/zsh-autosuggestions/",
	"title": "zsh-autosuggestions",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/zsh-completions/",
	"title": "zsh-completions",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/zsh-syntax-highlighting/",
	"title": "zsh-syntax-highlighting",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/prettify_your_mac_terminal/",
	"title": "打造好用且美觀的 Terminal",
	"tags": ["iTerm2", "zsh", "oh-my-zsh", "powerlevel9k", "zsh-completions", "zsh-autosuggestions", "zsh-syntax-highlighting"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "身為一個程式設計師，隨身有一個好用的 command line tool，也是很正常的～\n我用的是 iterm2 + zsh + oh-my-zsh，這裡就不贅述是為什麼了（因為這組合太多人用了，網路上文章很多拉～），再修改一些設定和加上一些 plugin 來改造 command line 環境。\n 接下來會用到 Homebrew 和 brew cask，需先準備好\n 安裝 iTerm2 1  $ brew cask install iterm2   修改 iTerm2 的 color scheme 一開始 iTerm2 預設的樣式實在不是很美觀，還好網友有分享了很多的樣板可以挑選。\n可以參考 iTerm2 Color Schemes，裡面有許多已調好的樣式可以挑選，我自己是挑了以下幾套。\n Solarized Darcula   ToyChest  再來就是修改設定了，參照以下的步驟：\n Preferences \u0026gt; Profiles \u0026gt; Terminal \u0026gt; Report Terminal Type\n 將其設為 xterm-256color，等等才能看得到漂亮的顏色，然後到下面的位置去匯入和選用剛剛挑的 color scheme。\n Preferences \u0026gt; Profiles \u0026gt; Colors \u0026gt; Color Presets\u0026hellip;\n 安裝字型 接下來的 Theme 會用到特殊的 icon，目前只支援 Powerline / Awesome / Nerd 三種字型，我是選 Nerd 字型，因為它的 icon 最完整，且支援 homebrew 安裝。\n1 2 3 4  $ brew tap caskroom/fonts $ brew cask search nerd # 找你喜歡的字體 $ brew cask install font-sourcecodepro-nerd-font   安裝 zsh 1 2 3 4 5 6 7 8 9 10 11 12  $ brew install zsh # 把 zsh 加進 shell 清單 # http://linux.vbird.org/linux_basic/0320bash.php#bash_shells $ sudo sh -c \u0026#34;echo $(which zsh)\u0026gt;\u0026gt; /etc/shells\u0026#34; # 把 zsh 設定為你的預設 shell # http://linux.vbird.org/linux_basic/0410accountmanager.php#chsh $ chsh -s $(which zsh) # 確認 Shell 是 zsh $ echo $SHELL   安裝 oh-my-zsh  參考：https://github.com/robbyrussell/oh-my-zsh\n 預設安裝路徑為 ~/.oh-my-zsh\n1  $ sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34;   Theme Oh My Zsh 內建了許多的 Theme，可到它的 Github 裡去挑選。\n檔案路徑在 ~/.oh-my-zsh/themes 之中，可以透過修改 .zshrc 的 ZSH_THEME 參數來替換，像是要替換成 agnoster，就會修改成以下的樣子。\n1  ZSH_THEME=\u0026#34;agnoster\u0026#34;   但這裡我們要用 powerlevel9k，這個 Theme 並不包含在 default 的 Theme\n安裝 zsh theme: powerlevel9k 1  $ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k   設定 powerlevel9k 透過修改 ~/.zshrc 以及參照 官方文件 可以使用不少的功能，但要小心載入過多的功能導致效能變差。\n 這是我採用的設定，可以照個人需求調整  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 採用 nerd 字型（一定要放在套用 Theme 之前） POWERLEVEL9K_MODE=\u0026#39;nerdfont-complete\u0026#39; # 套用 powerlevel9k Theme ZSH_THEME=\u0026#34;powerlevel9k/powerlevel9k\u0026#34; DEFAULT_USER=\u0026#34;Tony\u0026#34; # command line 左邊想顯示的內容 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs) # command line 右邊想顯示的內容 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs command_execution_time time) # 顯示執行時間 POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=0   Plugin 官方推薦套件一覽：\nhttps://github.com/robbyrussell/oh-my-zsh/wiki/Plugins-Overview\n 這裡希望 plugin 集中在 ~/.oh-my-zsh/custom/plugins/ 目錄下管理，所以不採用 brew 安裝\n 最後修改 ~/.zshrc 裡的 plugins 加上選用的功能，以下是我的設定值\n1  plugins=(git sublime zsh-completions zsh-autosuggestions zsh-syntax-highlighting)   git 內建不需安裝\nsublime https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/sublime\n內建不需安裝\n1 2 3  $ st # 直接打開 sublime $ st file_name # 用 sublime 開文件 $ st dir_name # 用 sublime 開目錄   zsh-completions 按 tab 自動完成 command\nhttps://github.com/zsh-users/zsh-completions\n1  $ git clone https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions   zsh-autosuggestions 記憶下過的 commad，並在下一次提示\nhttps://github.com/zsh-users/zsh-autosuggestions\n1  $ git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions   zsh-syntax-highlighting https://github.com/zsh-users/zsh-syntax-highlighting\n1  $ clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting   結語 『工欲善其事，必先利其器』，每次看同事表演神手寫 code 時，都覺得好帥啊（疑？方向怎麼變成這樣？）\nCommand Line 是工程師每天都會用到的工具，有時候也需要長時間觀看，所以才想說趁這次好好的整理一下工具，這樣工作心情也會好得多，一舉數得啊～～\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/ca/",
	"title": "CA",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/certificate/",
	"title": "certificate",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/pki/",
	"title": "PKI",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/x.509/",
	"title": "X.509",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/x509/",
	"title": "X.509",
	"tags": ["X.509", "certificate", "PKI", "CA"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "延續上次簡介密碼學的時候有談到 PKI，今天要來看看 X.509 這個廣為使用的數位憑證標準。\n先來複習一下名詞吧\n Symmetric Encryption：對稱加密，加解密用同一把鎖\nAsymmetric Encryption：非對稱加密，用兩把鎖配合來加解密\nPublic Key：非對稱加密中可公開的鎖\nPrivate Key：非對稱加密中的私鑰，絕對不可外流\nSignature：數位簽章，通常是利用內容的 Hash 和 Private Key 所產生的，用來識別發送端身份\nMan-in-the-middle attack：中間人攻擊指的是駭客利用攔截和偽裝公鑰交換來竄改和轉發訊息\nPKI：公開金鑰基礎架構提供公鑰和證書的管理\nCA：Certificate Authority，認證機構也就是憑證簽發的機構\nCertificate：由 CA 所發的憑證，包含擁有者的資訊、CA、有效日期等訊息\nCSR（Certificate Signing Request）：憑證簽發請求文件，要透過這份文件去跟 CA 申請憑證\n 要是對上面沒印象的話就需要去看之前寫的 “{% post_link cryptography-introduction 密碼學簡介 %}” 或者 Google 一下相關資訊\n什麼是 X.509 X.509 是一種 PKI 的標準，由 ITU-T（國際電信聯盟）在 1988 年制定，基於其以前所制定的 ASN.1 標準。X.509 已用運在許多的面向，包括 TLS/SSL、IOT、電子簽名等等。\nCertificate 結構 在 X.509 憑證採用了 ASN.1 標準，當中包含了公鑰、身份資訊、簽名資訊、有效日期等資訊，大致結構如下：\nCertificate: 憑證 - Version: 版本 - Serial Number: 序號 - Signature Algorithm ID: 憑證簽署演算法 ID - Issuer: 簽發者 - Validity: 有效期 -- Not Before: 此日期前無效 -- Not After: 此日期後無效 - Subject: 擁有者 - Subject Public Key Info: 擁有者公鑰資訊 -- Public Key Algorithm: 公鑰演算法 -- Subject Public Key: 公鑰 - Issuer Unique Identifier (Optional): 簽發者唯一識別 - Subject Unique Identifier (Optional): 擁有者唯一識別 - Extensions (Optional): 擴充 - Certificate Signature Algorithm: 憑證簽署演算法 - Certificate Signature: 憑證簽章值 Certificate 副檔名 X.509 中常用的副檔名如下，其中部分還有其他用途：\n  .pem -(Privacy Enhanced Mail)：\n以 Base64 編碼 DER 憑證，並存放在 “\u0026mdash;\u0026ndash;BEGIN CERTIFICATE\u0026mdash;\u0026ndash;” 和 “\u0026mdash;\u0026ndash;END CERTIFICATE\u0026mdash;\u0026ndash;” 之間。\n  .cer, .crt, .der\n常使用二進位的 DER 編碼或 Base64 編碼做憑證\n  .p7b, .p7c\nPKCS#7 憑證結構，不包含資料。\n  .p12\nPKCS#12 格式包含憑證的公鑰及私鑰 (同時有密碼保護)。\n  .pfx\nPFX, PKCS#12 的前身\n  .bks\nAndroid 用的憑證，由 Bouncy Castle 所實現的 Java Keystore\n  什麼是 Certificate Chain Certificate Chain（憑證鏈）顧名思義是一連串的 Certificate，由 Root CA（根憑證）為起點所延伸出的憑證鏈，在鏈中的每張證書都需要透過前一張驗證\n讓我們來看看 Google 的憑證鏈吧：在 Google 使用 HTTPS 時會需要一張 Certificate，而透過瀏覽器我們可以查看到這張 Certificate 所核發的是 *.google.com，代表著 google.com 下的所有網站皆適用這張憑證。然後一路追溯到 GlobalSign 這張根憑證，而 GlobalSign 包含在瀏覽器之中，故可以被信任。\nX.509 Sample 延續上面的，以 Google 的憑證來做範例，這裡就解碼來看一下憑證的內容，驗證一下剛剛的理論吧。\n在瀏覽器之中會認得數家的 CA，透過憑證鏈可得知是由誰所核發的憑證，所以只要是認可的 CA 所核發的就沒有問題了。\n但是連上沒有擁有認可過憑證的網站的話就會發出警告並交由用戶決定。\n而最後瀏覽器傳送了 key 給 Service，這就要講到 SSL 的交握過程了，非對稱加密雖然安全，但同時犧牲了速度，所以 SSL 採用階段式的做法，在第一階段用非對稱加密，來傳送 “Key”，而這把 Key 就是第二階段對稱加密用來傳送資料的。\n然後讓我們來看看憑證內容吧，這裡我節錄了 www.google.com 的憑證\n第一張憑證是 *.googlecomtw.crt，從 Subject 的 CN 中可以看出他是給哪個 host 用的，裡面也提到了用的是 SHA-256 with RAS 演算法和簽發者是 Google Internet Authority G3 Validity。\nCertificate: Data: Version: 3 (0x2) Serial Number: 4164209266253688074 (0x39ca3e43c570ed0a) Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Google Trust Services, CN=Google Internet Authority G3 Validity Not Before: Apr 17 13:42:40 2018 GMT Not After : Jul 10 12:39:00 2018 GMT Subject: C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.google.com.tw Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00 Exponent: 65537 (0x10001) ... 而要驗證 *.googlecomtw.crt 這張憑證則需要驗證 GoogleInternetAuthorityG3.crt 這張憑證，同樣也需要下一張憑證來驗證。\nCertificate: Data: Version: 3 (0x2) Serial Number: 01:e3:a9:30:1c:fc:72:06:38:3f:9a:53:1d Signature Algorithm: sha256WithRSAEncryption Issuer: OU=GlobalSign Root CA - R2, O=GlobalSign, CN=GlobalSign Validity Not Before: Jun 15 00:00:42 2017 GMT Not After : Dec 15 00:00:42 2021 GMT Subject: C=US, O=Google Trust Services, CN=Google Internet Authority G3 Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00 Exponent: 65537 (0x10001) ... GlobalSignRootCA-R2.crt 則是一張根憑證，因為是自己簽署的，所以 Subject 和 會一樣。\nCertificate: Data: Version: 3 (0x2) Serial Number: 04:00:00:00:00:01:0f:86:26:e6:0d Signature Algorithm: sha1WithRSAEncryption Issuer: OU=GlobalSign Root CA - R2, O=GlobalSign, CN=GlobalSign Validity Not Before: Dec 15 08:00:00 2006 GMT Not After : Dec 15 08:00:00 2021 GMT Subject: OU=GlobalSign Root CA - R2, O=GlobalSign, CN=GlobalSign Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00: 00:00 Exponent: 65537 (0x10001) ... 了解了概念以後就來實做看看吧～\n實作 X.509 產生金鑰 一開始要先有 RSA 公私鑰\n產生私鑰 1 2 3  $ openssl genrsa -out private.key 2048 # 產生長度為 2048 bits 名為 private.key 的 public key # 長度越長越安全，但加解密時間越長   藉由私鑰產生公鑰 1 2 3 4  $ openssl rsa -in private.key -pubout -out public.key # -in 輸入私鑰 # -pubout 代表輸出一個公鑰 # -out 公鑰檔名   產生 CSR 要跟 CA 申請憑證的第一步就是要有身份證明文件，但私鑰是不能流出的而且資訊也不太充足，透過 CSR ，裡面會包含許多資訊來給 CA 去做簽署\n1 2 3  $ openssl req –new –key private.key -out CSR.csr # -new 表示產生 CSR # -key 搭配的 key   在 CSR 可能含有以下資訊\nCommon Name [CN]：簽署名稱，也就是網域名稱 Organization [O]：組織名稱 Organizational Unit [OU]：組織單位，若沒填寫則跟 Common Name 相同 Country [C]：所在國家 State [ST]：所在的州或省 Locality [L]：所在城市 Key Size：憑證演算法與金鑰長度 產生證書 自簽 Root 憑證 1 2 3 4  $ openssl x509 -req -days 365 \\ -in CSR.csr \\ -signkey private.key \\ -out RootCA.crt   用 Root CA 簽發憑證 做一個新的 private key \u0026amp; CSR，private2.key \u0026amp; CSR2.csr\n1 2 3 4 5  $ openssl x509 -req -days 3650 \\ -CA RootCA.crt \\ -in CSR2.csr \\ -CAkey private2.key \\ -out myhost.crt   查看 PEM 編碼憑證 1  $ openssl x509 -in certificate.pem -text -noout   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/asymmetric-encryption/",
	"title": "Asymmetric encryption",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/cryptography/",
	"title": "cryptography",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/signature/",
	"title": "Signature",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/symmetric-encryption/",
	"title": "Symmetric Encryption",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/cryptography-introduction/",
	"title": "密碼學簡介",
	"tags": ["cryptography", "對稱加密", "Symmetric Encryption", "非對稱加密", "Asymmetric encryption", "數位簽章", "Signature", "PKI", "X.509", "CA"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "在傳遞資料的時候，若是不希望別人看到，那麼我們就會把內容做適當的處理。在現實生活中其實隨處可見密碼學的概念，我們就來想像以下的情境吧。\n Tony 想傳情書給 Whitney，但不想給別人看到，他們會怎麼做呢？\n 對稱加密（Symmetric Encryption）  一開始他們就把信交給郵差之前，將它裝到盒子裡上鎖，各拿一把鑰匙，透過郵差拿到盒子後再把鎖打開\n 對稱加密，溝通雙方拿著一樣的金鑰，有鑰匙的人就可以自由開關，而沒有鑰匙的人就算拿到保險箱也打不開，常見的有：DES、AES\n非對稱加密（Asymmetric encryption）  但是這又有一個問題了，當他們分隔兩地時，第一次要怎麼傳遞鑰匙呢？要是不小心被別人拿去了呢？所以他們就找了一個特製的鎖（如下圖），一把鑰匙只可以從 A 轉到 C（\\(K_p\\)），另一把只能從 C 到 A（\\(K_s\\)）。\n一開始 Tony 會把 \\(K_p\\) 寄給 Whitney，然後再把上鎖的盒子給她，Whitney 收到盒子後就可以用 \\(K_p\\) 打開。\n這樣的方法就算 \\(K_p\\) 流出，在傳遞的過程中也無法變造內容，因為需要 \\(K_s\\) 才能完整操作盒子。\n 非對稱式加密會有兩個金鑰，通常給出去的稱作公鑰（\\(K_p\\)），留在本地的稱做私鑰（\\(K_s\\)），加解密是需要兩組配合才能運作。用私鑰加密，就要用公鑰解密；用公鑰加密就用私鑰解密。\n而實際狀況通常會是雙方都會有各自的公私鑰，同時也會有對方的公鑰。在 A 傳給 B 時用 B 的 \\(K_p\\) 加密，B 收到後再用自己的 \\(K_s\\) 解密；在 B 傳給 A 時用 A 的 \\(K_p\\) 加密，A 收到後用自己的 \\(K_s\\) 解密。\n依照這個特性，就不用怕公鑰流出去，因為需要私鑰的配合才能讓訊息加解密，而私鑰從來沒有流通過，就不可能被攔截。\n數位簽章（Signature）  上面的方法看起來安全了，但我們來想想看，假設中間 Tony 的公鑰在傳輸給 Whitney 時流出了，那麼 Tony 不就沒辦法驗證訊息是不是 Whitney 傳的嗎？\n他們就又想了一個方法，既然我們有兩個盒子，何不一個驗證身份一個驗證內容呢？\n所以 Tony 在傳送訊息同時，用自己的 \\(K_s\\) 加密身份，一起傳給 Whitney，Whitney 再用 Tony 的 \\(K_p\\) 來看是不是真的是 Tony 寄的訊息。這樣就可以確認內容跟身份都正確了。\n 數位簽章利用的就是非對稱加密的特性，反向讓私鑰幫你加密訊息，公鑰解密。那麼可能有人會問，公鑰不是所有人都可能知道嗎？但不怕，因為就算可以用公鑰解密，那也只是知道是誰記得而已，訊息本身還是沒辦法得知。\n中間人攻擊（Man-in-the-middle attack）  剛剛上面的假設都是傳遞過程不被竄改，但要是內鬼就是郵差的話，會發生什麼事呢？\n  郵差拿到 Tony 的 \\(K_p\\)，並把自己的 \\(K_p\\scriptscriptstyle 1\\) 給 Whitney\n  郵差拿到 Whitney 的 \\(K_p\\)，並把自己的 \\(K_p\\scriptscriptstyle 2\\) 給 Tony\n  郵差拿到 Tony 的信和簽名時，如之前所說信是用 Whitney 的 \\(K_p\\) 加密（但這裡 Tony 拿到的其實是郵差的 \\(K_p\\scriptscriptstyle 2\\)），簽名是用 Tony 的 \\(K_s\\) 加密，分別用郵差的 \\(K_s\\scriptscriptstyle 2\\) 和 Tony 的 \\(K_p\\) 解密，竄改後再用自己的 \\(K_s\\scriptscriptstyle 1\\) 和 Whitney 的 \\(K_p\\) 加密，這樣的話 Whitney 就會信以為真了\n 非對稱加密在通訊的過程中若是經過了 Hacker 的路由，就有可能導致上述的狀況，也稱作中間人攻擊，為了對應這種情況而孕育出 PKI（Public Key Infrasture, 公鑰基礎建設）\nPKI（Public Key Infrasture）  有了上述的狀況，兩個人就想說是不是找一個認證過的機構來幫我們傳遞消息？可能是郵局、快遞公司，而不是一般的路人\n PKI 是提供公鑰加密和數位簽章服務的系统或平台，目的是為了管理金鑰和證書。這裡就不說明細部的數學計算，讓我們從流程來看看它是如何提供安全的服務。\n真實的流程中，用戶會透過 CSR 證書向認證機構（CA）申請 X.509 ，其中包含更多資訊，流程也比下圖複雜的多，這裡只簡單闡述概念。\n 一開始認證機構（CA）會給雙方機構的 \\(K_p\\)\n  Tony 將他的 \\(K_p\\) 送到機構去加密，經過機構的運算後，會回傳一張證書（Certificate）\n  Tony 就將 Certificate 和 \\(K_p\\) 傳給 Whitney，Whitney 利用機構的 \\(K_p\\) 解開 Certificate 後 得到 \\({K_p}\\rq\\)，\\({K_p}\\rq\\) 和收到的 \\(K_p\\) 一致代表這個傳輸是可靠有效的。\n 上面有提到 KPI 的一個特性，CA 的 \\(K_p\\) 通常會隨著系統、瀏覽器的安裝而包含在內，這也就是說 CA 的 \\(K_p\\) 不是透過傳輸，而是預先安裝在系統中的，也就不會再傳輸的過程中被攔截和竄改，這也就是“基礎設施”的由來。\n結語 資訊安全一直都是熱門的議題，近年來網路的運用越來越普及，像是 IOT 的裝置或者是微服務的盛行，每一個系統在設計時都少不了安全機制的考慮，而密碼學提供了保密性（Confidentiality）、完整性（Integrity）、可用性（Availability），透過密碼學的基礎設計安全的通道來讓各個服務溝通，以保系統安全無虞。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/%E5%B0%8D%E7%A8%B1%E5%8A%A0%E5%AF%86/",
	"title": "對稱加密",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0/",
	"title": "數位簽章",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%8A%A0%E5%AF%86/",
	"title": "非對稱加密",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/go/",
	"title": "Go",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/golang/",
	"title": "Golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/golang-json/",
	"title": "Golang JSON 處理",
	"tags": ["Go", "golang", "json"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "JSON（JavaScript Object Notation）是一種輕量級的資料交換語言，以純文字為基礎去儲存資料，有相容性高、易於理解且許多程式語言都支援等優點。\n而在 Golang 之中是如何處理 JSON 的呢？\nGolang 官方的 package 中已有支援 JSON，可很容易的對 JSON 數據做編解碼\n數據結構   types JSON Golang   字串 string string   整數 number int   浮點數 number flaot64   陣列 array slice   物件 object struct   布林 bool bool   空值 null nil   JSON 編碼 JSON 套件裡面透過 Marshal 函數來將數據處理成 JSON 字串\n1  func Marshal(v interface{}) ([]byte, error)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int Name string Money float64 Skills []string Relationship map[string]string Identification Identification } type Identification struct { Phone bool Email bool } func main() { user := User { ID: 1, Name: \u0026#34;Tony\u0026#34;, Skills: []string{\u0026#34;program\u0026#34;, \u0026#34;rich\u0026#34;, \u0026#34;play\u0026#34;}, Relationship: map[string]string { \u0026#34;Dad\u0026#34;: \u0026#34;Hulk\u0026#34;, \u0026#34;Mon\u0026#34;: \u0026#34;Natasha\u0026#34;, }, Identification: Identification { Phone: true, Email: false, }, } b, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } fmt.Println(string(b)) }   輸出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { \u0026#34;ID\u0026#34;:1, \u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;, \u0026#34;Money\u0026#34;:0, \u0026#34;Skills\u0026#34;: [ \u0026#34;program\u0026#34;, \u0026#34;rich\u0026#34;,\u0026#34;play\u0026#34; ], \u0026#34;Relationship\u0026#34;: { \u0026#34;Dad\u0026#34;:\u0026#34;Hulk\u0026#34;, \u0026#34;Mon\u0026#34;:\u0026#34;Natasha\u0026#34; }, \u0026#34;Identification\u0026#34;: { \u0026#34;Phone\u0026#34;:true, \u0026#34;Email\u0026#34;:false } }   從上面的例子看到 key 值都是大寫，因只有大寫的才會被輸出，但若是需要小寫或其他的名稱怎麼辦呢？ Golang 提供了 struct tag 來實現\n1 2 3 4 5 6  ... type Identification struct { Phone bool `json:\u0026#34;phone\u0026#34;` Email bool `json:\u0026#34;email\u0026#34;` } ...   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  { \u0026#34;ID\u0026#34;:1, \u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;, \u0026#34;Money\u0026#34;:0, \u0026#34;Skills\u0026#34;: [ \u0026#34;program\u0026#34;,\u0026#34;rich\u0026#34;,\u0026#34;play\u0026#34; ], \u0026#34;Relationship\u0026#34;: { \u0026#34;Dad\u0026#34;:\u0026#34;Hulk\u0026#34;, \u0026#34;Mon\u0026#34;:\u0026#34;Natasha\u0026#34; }, \u0026#34;Identification\u0026#34;: { \u0026#34;phone\u0026#34;:true, \u0026#34;email\u0026#34;:false } }   struct tag 還可以有以下功能（取自官方文件） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // Field appears in JSON as key \u0026#34;myName\u0026#34;. Field int `json:\u0026#34;myName\u0026#34;` // Field appears in JSON as key \u0026#34;myName\u0026#34; and // the field is omitted from the object if its value is empty, // as defined above. Field int `json:\u0026#34;myName,omitempty\u0026#34;` // Field appears in JSON as key \u0026#34;Field\u0026#34; (the default), but // the field is skipped if empty. // Note the leading comma. Field int `json:\u0026#34;,omitempty\u0026#34;` // Field is ignored by this package. Field int `json:\u0026#34;-\u0026#34;` // Field appears in JSON as key \u0026#34;-\u0026#34;. Field int `json:\u0026#34;-,\u0026#34;`   又或者需要將輸出全部改為 String，Golang 也有提供此功能\n1  Int64String int64 `json:\u0026#34;,string\u0026#34;`   JSON 解碼 相較 JSON 編碼來說，Golang 對於未知的 JSON 實在是一大挑戰，一開始我們先從已知的結構來看\n透過 Unmarshal 將 JSON 字串處理成對應的結構\n1  func Unmarshal(data []byte, v interface{}) error   直接來看例子吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int Name string Money float64 Skills []string Relationship map[string]string Identification Identification } type Identification struct { Phone bool `json:\u0026#34;phone\u0026#34;` Email bool `json:\u0026#34;email\u0026#34;` } func main() { var jsonBlob = []byte(`{\u0026#34;ID\u0026#34;:1,\u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;,\u0026#34;Money\u0026#34;:0,\u0026#34;Skills\u0026#34;:[\u0026#34;program\u0026#34;,\u0026#34;rich\u0026#34;,\u0026#34;play\u0026#34;],\u0026#34;Relationship\u0026#34;:{\u0026#34;Dad\u0026#34;:\u0026#34;Hulk\u0026#34;,\u0026#34;Mon\u0026#34;:\u0026#34;Natasha\u0026#34;},\u0026#34;Identification\u0026#34;:{\u0026#34;phone\u0026#34;:true,\u0026#34;email\u0026#34;:false}}`) var user User err := json.Unmarshal(jsonBlob, \u0026amp;user) if err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } fmt.Printf(\u0026#34;%+v\u0026#34;, user) }   解碼與編碼類似，但接受大小寫不同，不過如果欄位是私有的則不會配對\nstruct tag 如同在編碼的時候，解碼也有對應的 tag，就讓我們來看看吧\n string tag 表示只有字串會被解析，當傳入的值不是字串時會報錯  1 2 3 4 5 6 7 8 9 10  ... type User struct { ID int Name string Money float64 `json:\u0026#34;,string\u0026#34;` Skills []string Relationship map[string]string Identification Identification } ...   正確：\n\u0026quot;Money\u0026quot;:\u0026quot;100.5\u0026quot; 錯誤：\n\u0026quot;Money\u0026quot;:100.5 error: json: invalid use of ,string struct tag, trying to unmarshal unquoted value into float64  - 表示不會被解析，但會給予初始值  動態解析 JSON 以上介紹的都是理想的狀況，但實際開發時會常常遇到未知的 JSON 格式，或是動態變化的結構，這時候就可以利用以下方法\ninterface \u0026amp; assertion 先利用 interface 來儲存任意的數據結構，再利用 assertion 的方式解析數據\n1  map[string]interface{}   範例 a：interface 儲存輸入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var user map[string]interface{} var jsonString string = `{\u0026#34;ID\u0026#34;:1, \u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;}` if err := json.Unmarshal([]byte(jsonString), \u0026amp;user); err != nil { fmt.Println(\u0026#34;ERROR:\u0026#34;,err) } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, user) }   範例 b：用 assertion 來解析數據\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int Name string Money float64 `json:\u0026#34;,string\u0026#34;` Skills []string Relationship map[string]string Identification Identification Career string Responsibility interface {} } type Identification struct { Phone bool `json:\u0026#34;phone\u0026#34;` Email bool `json:\u0026#34;email\u0026#34;` } func main() { var jsonBlob = []byte(`[ {\u0026#34;ID\u0026#34;:1, \u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;, \u0026#34;Career\u0026#34;:\u0026#34;Engineer\u0026#34;, \u0026#34;Responsibility\u0026#34;:{\u0026#34;skill\u0026#34;:\u0026#34;PHP\u0026amp;Golang\u0026amp;Network\u0026#34;, \u0026#34;description\u0026#34;:\u0026#34;coding\u0026#34; } }, {\u0026#34;ID\u0026#34;:2, \u0026#34;Name\u0026#34;:\u0026#34;Jim\u0026#34;, \u0026#34;Career\u0026#34;:\u0026#34;Manager\u0026#34;, \u0026#34;Responsibility\u0026#34;:{\u0026#34;experienced\u0026#34;:true } } ]`) var users []User if err := json.Unmarshal(jsonBlob, \u0026amp;users); err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, users) fmt.Println(users[0].Responsibility.(map[string]interface{})[\u0026#34;description\u0026#34;].(string)) fmt.Println(users[1].Responsibility.(map[string]interface{})[\u0026#34;experienced\u0026#34;].(bool)) }   雖然可利用上述方式，但是 code 實在不是很美觀，尤其是在讀出資料的時候\n利用 *json.RawMessage 延遲解析 上述結構內的 Responsibility 實際上是在解析 Career 才會知道它的資料結構，這時候就可以使用 json.RawMessage 來延遲解析，讓數據以 byte 的方式繼續存在，等待下一次的解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { ID int Name string Money float64 `json:\u0026#34;,string\u0026#34;` Skills []string Relationship map[string]string Identification Identification Career string Responsibility json.RawMessage } type Identification struct { Phone bool `json:\u0026#34;phone\u0026#34;` Email bool `json:\u0026#34;email\u0026#34;` } type Engineer struct { Skill string `json:\u0026#34;skill\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } type Manager struct { Experienced bool `json:\u0026#34;experienced\u0026#34;` } func main() { var jsonBlob = []byte(`[ {\u0026#34;ID\u0026#34;:1, \u0026#34;Name\u0026#34;:\u0026#34;Tony\u0026#34;, \u0026#34;Career\u0026#34;:\u0026#34;Engineer\u0026#34;, \u0026#34;Responsibility\u0026#34;:{\u0026#34;skill\u0026#34;:\u0026#34;PHP\u0026amp;Golang\u0026amp;Network\u0026#34;, \u0026#34;description\u0026#34;:\u0026#34;coding\u0026#34; } }, {\u0026#34;ID\u0026#34;:2, \u0026#34;Name\u0026#34;:\u0026#34;Jim\u0026#34;, \u0026#34;Career\u0026#34;:\u0026#34;Manager\u0026#34;, \u0026#34;Responsibility\u0026#34;:{\u0026#34;experienced\u0026#34;:true } } ]`) var users []User if err := json.Unmarshal(jsonBlob, \u0026amp;users); err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } for _, user := range users { switch user.Career { case \u0026#34;Engineer\u0026#34;: var responsibility Engineer if err := json.Unmarshal(user.Responsibility, \u0026amp;responsibility); err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } fmt.Println(responsibility.Description) case \u0026#34;Manager\u0026#34;: var responsibility Manager if err := json.Unmarshal(user.Responsibility, \u0026amp;responsibility); err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) } fmt.Println(responsibility.Experienced) default: fmt.Println(\u0026#34;warning:\u0026#34;, \u0026#34;don\u0026#39;t exist\u0026#34;) } } }   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/json/",
	"title": "json",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/datum/",
	"title": "Datum",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/gps/",
	"title": "GPS",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/gps-introduction/",
	"title": "GPS 簡介",
	"tags": ["GPS", "Datum", "TWD67", "TWD97", "WGS84", "Haversine", "Vincenty"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "GPS 英文全名是：Global Positioning System，全球定位系統\n一般來說要表示地理位置都會用座標來標示，實際上用座標是不夠清楚的，因為所指的座標是用什麼基準的並沒有說明。明確的地理位置會用大地基準（Datum）＋坐標格式（Format／Grid）兩個參數來標示。\n大地座標系統（Datum） Datum 是由數學模式所計算出來的地球外形，目前台灣常見的有三種：TWD67、TWD97、WGS84；其中 TWD67 是依據 1967 年的國際地球原子參數所定，以埔里虎子山為測量原點；TWD97 是依據 1980 年的國際地球原子參數而定；WGS84 則是以地球質心為原點，透過遍佈世界的衛星觀測站觀測到的坐標而建立的。\n座標格式 經緯度在表示時因“度”單位太大，所以將度細分為分＆秒，一度 60 分，一分 60 秒，故有三種表示法：\n DD 度 : 41.40338, 2.17403 DMM 度分 : 41 24.2028, 2 10.4418 DMS 度分秒 : 41°24'12.2\u0026quot;N 2°10'26.5\u0026quot;E  座標距離 因地球並非正圓體，而是在赤道地區較膨脹＆兩極扁平，呈橢圓體，故在計算兩點距離時並不是這麼好計算。\n法一： 假設地球為圓球體，計算球體上兩個點的距離又稱大圓距離 (The Great Circle Distance)：\n{% asset_img great-circle-distance.jpg Great-circle Distance %}\n可利用 Great-circle distance 公式：\n或利用 Haversine 公式：\n1 2 3  a = sin²(Δφ/2) + cos φ1 ⋅ cos φ2 ⋅ sin²(Δλ/2) c = 2 ⋅ atan2( √a, √(1−a) ) d = R ⋅ c   JS Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function distanceByHaversine(lat1, lon1, lat2, lon2) { var R = 6371e3; // metres  var φ1 = lat1 * Math.PI / 180; var φ2 = lat2 * Math.PI / 180; var Δφ = (lat2-lat1) * Math.PI / 180; var Δλ = (lon2-lon1) * Math.PI / 180; var a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2); var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); var d = R * c; return d; }   PHP Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function distanceByHaversine($lat1, $lon1, $lat2, $lon2) { $R = 6371e3; // metres $latR1 = $lat1 * pi() / 180; $lonR1 = $lon1 * pi() / 180; $latR2 = $lat2 * pi() / 180; $lonR2 = $lon2 * pi() / 180; $x = $latR2 - $latR1; $y = $lonR2 - $lonR1; $a = sin($x / 2) * sin($x / 2) + cos($latR1) * cos($latR2) * sin($y / 2) * sin($y / 2); $c = 2 * atan2(sqrt($a), sqrt(1 - $a)); $d = $R * $c; return $d; }   法二： 然而地球不是正圓體，如果用上述的方式難免有誤差，因此 Thaddeus Vincenty 在 1975 年提出了 Vincenty's formula 以用來計算橢圓球體，可精確到 0.5 mm 以內\n  a 橢圓體半長軸長度（赤道半徑） 6378137.0m（WGS84）   ƒ 扁率 1/298.257223563（WGS84）   b = (1 − ƒ) a 橢球體半短軸長度（兩極半徑） 6356752.314245m（WGS84）   JS Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  function distanceByVincenty(lat1, long1, lat2, long2) { var a = 6378137; var b = 6356752.314245; var f = 1 / 298.257223563; var φ1 = lat1 * Math.PI / 180; var λ1 = long1 * Math.PI / 180; var φ2 = lat2 * Math.PI / 180; var λ2 = long2 * Math.PI / 180; var L = λ2 - λ1; var tanU1 = (1-f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1; var tanU2 = (1-f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2*tanU2)), sinU2 = tanU2 * cosU2; var λ = L, λʹ, iterationLimit = 100; do { var sinλ = Math.sin(λ), cosλ = Math.cos(λ); var sinSqσ = (cosU2*sinλ) * (cosU2*sinλ) + (cosU1*sinU2-sinU1*cosU2*cosλ) * (cosU1*sinU2-sinU1*cosU2*cosλ); var sinσ = Math.sqrt(sinSqσ); if (sinσ==0) return 0; // co-incident points  var cosσ = sinU1*sinU2 + cosU1*cosU2*cosλ; var σ = Math.atan2(sinσ, cosσ); var sinα = cosU1 * cosU2 * sinλ / sinσ; var cosSqα = 1 - sinα*sinα; var cos2σM = cosσ - 2*sinU1*sinU2/cosSqα; if (isNaN(cos2σM)) cos2σM = 0; // equatorial line: cosSqα=0 (§6)  var C = f/16*cosSqα*(4+f*(4-3*cosSqα)); λʹ = λ; λ = L + (1-C) * f * sinα * (σ + C*sinσ*(cos2σM+C*cosσ*(-1+2*cos2σM*cos2σM))); } while (Math.abs(λ-λʹ) \u0026gt; 1e-12 \u0026amp;\u0026amp; --iterationLimit\u0026gt;0); if (iterationLimit==0) throw new Error(\u0026#39;Formula failed to converge\u0026#39;); var uSq = cosSqα * (a*a - b*b) / (b*b); var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq))); var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq))); var Δσ = B*sinσ*(cos2σM+B/4*(cosσ*(-1+2*cos2σM*cos2σM)- B/6*cos2σM*(-3+4*sinσ*sinσ)*(-3+4*cos2σM*cos2σM))); var s = b*A*(σ-Δσ); var fwdAz = Math.atan2(cosU2*sinλ, cosU1*sinU2-sinU1*cosU2*cosλ); var revAz = Math.atan2(cosU1*sinλ, -sinU1*cosU2+cosU1*sinU2*cosλ); return s }   PHP Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  function distanceByVincenty($lat1, $long1, $lat2, $long2) { $a = 6378137; $b = 6356752.314245; $f = 1 / 298.257223563; $L = deg2rad($long2 - $long1); $tanU1 = (1 - $f) * tan(deg2rad($lat1)); $cosU1 = 1 / sqrt(1 + $tanU1 * $tanU1); $sinU1 = $tanU1 * $cosU1; $tanU2 = (1 - $f) * tan(deg2rad($lat2)); $cosU2 = 1 / sqrt(1 + $tanU2 * $tanU2); $sinU2 = $tanU2 * $cosU2; $lambda = $L; $iterLimit = 100; do { $sinLambda = sin($lambda); $cosLambda = cos($lambda); $sinSigma = sqrt(($cosU2 * $sinLambda) * ($cosU2 * $sinLambda) + ($cosU1 * $sinU2 - $sinU1 * $cosU2 * $cosLambda) * ($cosU1 * $sinU2 - $sinU1 * $cosU2 * $cosLambda)); if ($sinSigma == 0) { return 0; } $cosSigma = $sinU1 * $sinU2 + $cosU1 * $cosU2 * $cosLambda; $sigma = atan2($sinSigma, $cosSigma); $sinAlpha = $cosU1 * $cosU2 * $sinLambda / $sinSigma; $cosSqAlpha = 1 - $sinAlpha * $sinAlpha; if ($cosSqAlpha == 0) { $cos2SigmaM = 0; } else { $cos2SigmaM = $cosSigma - 2 * $sinU1 * $sinU2 / $cosSqAlpha; } $C = $f / 16 * $cosSqAlpha * (4 + $f * (4 - 3 * $cosSqAlpha)); $lambdaP = $lambda; $lambda = $L + (1 - $C) * $f * $sinAlpha * ($sigma + $C * $sinSigma * ($cos2SigmaM + $C * $cosSigma * (-1 + 2 * $cos2SigmaM * $cos2SigmaM))); } while (abs($lambda - $lambdaP) \u0026gt; 0.000000000001 \u0026amp;\u0026amp; --$iterLimit \u0026gt; 0); if ($iterLimit == 0) { return 0; } $uSq = $cosSqAlpha * ($a * $a - $b * $b) / ($b * $b); $A = 1 + $uSq / 16384 * (4096 + $uSq * (-768 + $uSq * (320 - 175 * $uSq))); $B = $uSq / 1024 * (256 + $uSq * (-128 + $uSq * (74 - 47 * $uSq))); $deltaSigma = $B * $sinSigma * ($cos2SigmaM + $B / 4 * ($cosSigma * (-1 + 2 * $cos2SigmaM * $cos2SigmaM) - $B / 6 * $cos2SigmaM * (-3 + 4 * $sinSigma * $sinSigma) * (-3 + 4 * $cos2SigmaM * $cos2SigmaM))); return $b * $A * ($sigma - $deltaSigma); }   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/haversine/",
	"title": "Haversine",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/twd67/",
	"title": "TWD67",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/twd97/",
	"title": "TWD97",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/vincenty/",
	"title": "Vincenty",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/wgs84/",
	"title": "WGS84",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/efs/",
	"title": "EFS",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/fcntl/",
	"title": "fcntl",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/file-locking/",
	"title": "File Locking",
	"tags": ["Linux", "Golang", "PHP", "lock", "flock", "fcntl", "EFS"],
	"categories": [],
	"series": [],
	"description": "",
	"content": " 再動手寫這篇之前，我踩到了一個雷，這篇描述了一下我遇到的問題跟解法，若是有人有更好的想法，或是我哪裡有搞錯了，請告訴我，我會非常感謝的！！！\n 遇到問題 用 Golang 寫了一隻利用 goroutine 去做事的程式，並放在 AWS EC2 spot fleet 去做 auto scale，其中每台 EC2 instances 上掛載了 EFS 把 Log 寫在內，運行了以後發現 Log 不完整，會有字串被截斷或消失的狀況。\nLinux File Locking Linux 是多人多工的系統，在使用上常會遇到同時編輯的狀況，若是一個 porcess 在讀取別的 process 正在讀寫的檔案，可能會讀到不完整的內容。再來我們來看一下在 Linux 中怎麼解決這個問題。\n在 Linux 中可依照鎖定的類型分為兩類：Advisory Lock（建議鎖） \u0026amp; Mandatory Lock（強制鎖），依照鎖定的動作也可以分為兩種：讀 \u0026amp; 寫，而鎖定後其他的 process 是否等待鎖定解除也可以再給予設定。\nAdvisory Lock 和 Mandatory Lock 的差別在於內核是否介入，在 advisory lock 中系統內核提供了加鎖及查詢是否鎖定的方法，但是不參與鎖的控制及協調，也就是說要是有 process 不遵守 “遊戲規則” 的話，內核並不會加以阻攔；而 mandatory lock 是透過內核去管理鎖，任何非允許的操作都會被內核阻攔。\n而所對於讀和寫的意義也不同，舉例來說：有 A \u0026amp; B process 分別對同一個檔案做操作，若 A \u0026amp; B 都是讀取（shared model），那麼倆倆不互相影響；但假設 A 是寫入的話，B 就有可能讀取到不正確的檔案，這時候就需要宣告 A 為寫入（exclusive model）。\n   當前類型    預計附加類型  shared (blocking) exclusive (blocking) Lastname Lastname   shared 正常讀取 等待讀取 正常讀取 EAGAIN   exclusive 等待寫入 等待寫入 EAGAIN EAGAIN    EAGAIN 表示 Resource temporarily unavailable\n Linux 透過 flock() 和 fcntl() 這兩個來實現 File Locking，還有一個是 lockf() 則是用 fcntl 封裝的，這裡就不深入說明了\nDeadlock 在使用鎖的同時也要注意是否會造成 Deadlock\n解決問題 這次我遇到的問題主要是沒有鎖定檔案所造成的，在查找資料的過程中將相關的知識都補充了一下。\n另外上面沒有提到的部分就是我利用了 goroutine，在 goroutine 切換的過程中針對同一資源去做操作，這部分要是只有單一 process 的話，只需要做好 mutex 就可，但以我的案例還多了 spot fleet。\n還有就是因為每個 EC2 instances 上掛載了 EFS，而 EFS 是透過 NFSv4.1 協定掛載的，故在加鎖的方式上須注意是否支援。\n以下就來說說實際的解決方案\nGolang 解決方案 在 Golang 中要避免讀寫問題有多種解法，端看遇到的情境決定，最單純的就是把檔案上鎖，而要將檔案上鎖需要透過 system call，在 windows \u0026amp; linux 的叫用方式又不同，這裡就直接上 code 了\n Linux  1 2 3  func LockFile(file *os.File) error { return syscall.Flock(int(file.Fd()), syscall.LOCK_EX) }    windows  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  func LockFile(file *os.File) error { h, err := syscall.LoadLibrary(\u0026#34;kernel32.dll\u0026#34;) if err != nil { return err } defer syscall.FreeLibrary(h) addr, err := syscall.GetProcAddress(h, \u0026#34;LockFile\u0026#34;) if err != nil { return err } for { r0, _, _ := syscall.Syscall6(addr, 5, file.Fd(), 0, 0, 0, 1, 0) if 0 != int(r0) { break } time.Sleep(100 * time.Millisecond) } return nil }   但若是單純一點的情況來說，只要利用議程鎖就可以了\n互斥鎖 這裡就不多講原理了，直接上 code\n1 2  var mutex sync.Mutex mutex.Lock()   另外 sync package 還針對讀寫所延伸的 RWMutex\n1 2 3 4 5  func (*RWMutex) Lock func (*RWMutex) Unlock func (*RWMutex) RLock func (*RWMutex) RUnlock   buffer 當操作系統做讀取寫入時需要透過 system call，而 system call 會直接影響效能，而透過 buffer 控制可以更有效的去呼叫 system call。\nGolang 的 bufio package 就提供了緩存寫入的功能，在存到硬碟之前會先存放在 buffer 中，在一次寫入。\nPHP 解決方案 這篇本來是要說 Golang 的，在查找資料的過程中也想用 PHP 來驗證，就順手紀錄了一下\nflock()\n在 Linux 上一樣屬於 advisory lock，但是在 windows 為 mandatory lock，在 Linux 上若需要更近一步的控制則需要 system call\n參考資料  File locking in Linux Linux文件锁 同步lock - Golang Working with Files in Go Windows和linux上的文件锁  "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/flock/",
	"title": "flock",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/linux/",
	"title": "Linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/lock/",
	"title": "lock",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/php/",
	"title": "PHP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/cache/",
	"title": "Cache",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/cache-control/",
	"title": "Cache-Control",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/etage/",
	"title": "ETage",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/http/",
	"title": "HTTP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/http-caching/",
	"title": "HTTP Caching",
	"tags": ["HTTP", "Cache", "Cache-Control", "ETage"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "近年來 Web 的服務越來越多樣化，其中不乏較大流量的服務，不僅增加傳輸的成本，也會拖慢 Browser 處理的時間，因此需要重複的利用之前所緩存的資源。\nCaching 機制 那就讓我們來看看 Caching 的機制是什麼\n在規範（https://tools.ietf.org/html/rfc7234）中將其分為 4.2. Freshness 和 4.3. Validation\nFreshness Cache Control \u0026amp; Expires 用來確認本地端的檔案是否過期，若是沒有過期則可以不需向 Server 驗證就可直接使用，就可以避免網路造成的延遲及傳輸成本。\n 補充說明：\n在 HTTP1.0 中定義了 Expires，Expires 的值是一個明確的過期時間，但這會碰到一個問題，因為 Expires 的時間是本地的時間，可能會與 Server 的不一致。\n因此在 HTTP1.1 中新添加了 Cache-Control，實現了更完整的 Caching 聲明；如 max-age 配置，用來表示檔案多久過期，而不是直接表示過期時間。\n假設設定值為：Cache-Control: max-age=30，在當前 Request 的 30 秒之內再次請求，則會取用 Cache，超過則會再次發送 Request。\n而根據 RFC2616 的定義：max-age 會蓋過 Expires。\n If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictiv\n  Validation Last-Modified \u0026amp; ETag 則是用來確認本地端的檔案是否與 Server 端的檔案符合，在 Browser 判斷 Cache 可能過期後則會向 Server 驗證檔案的一致性，若驗證通過則 Server 回覆 HTTP Status Code 304，否則返回 200 並回覆新的內容。\n 補充說明：\n在 HTTP1.0 中定義了 Last-Modified，當 Server 端回覆的 Response 中含有 Last-Modified（表示這個檔案的最後一次更新時間），則下次 Client 端送出的 Request 中為了要驗證是否有更新則會夾帶 If-Modified-Since（上次收到的 Last-Modified 值）給 Server 判斷。但 Last-Modified 還是有需要加強的地方，像是用時間來紀錄更新的狀態，但卻不代表檔案真的被更新過，另外時間的單位只有到秒，也不足代表。\n在 HTTP1.1 增加了 Etag，是利用類似 hash 的原理，來代表檔案是否一致，與 If-None-Match 標籤對應，但 Etag 在部分使用情境上還是會有問題，像是 Apache 中的 ETag 是用 inode、檔案大小和最後修改時間來產生的，在有負載平衡架構下，不同機器就會產生出不一樣的 ETag，但由於一般來說都會使用 CDN 技術，就交由專業的處理了。\n 主要就是透過 Freshness \u0026amp; Validation 這兩個機制來去做 Caching，以下舉個例子來了解一下吧：（為了方便理解，裡面的 Key \u0026amp; Value 並非實際數值）\n假設我第一次跟某個網站要了一張圖得到的回覆是（2018-01-01 13:00:00）\n1 2 3 4  Response Header Cache-Control: max-age=30day Last-Modified: 2017-12-25 10:00:00 ETag: validation_key   收到後就將其存進本地 Cache，在 10 天後我再次訪問這張圖片時，Browser 告訴我：『本地就有存擋了喔，直接給你吧』，於是就不發送請求，直接取用 Cache，Browser 會回應 200 OK (form disk cache)\n然後又過了一個月後我再次去看了這張圖，這次 Browser 發現已經過期了，所以它就送了 Request 去問 Server 這張圖從 2017-12-25 10:00:00 後有沒有更新\n1 2 3  Request Header If-Modified-Since: 2017-12-25 10:00:00 If-None-Match: validation_key   要是更新了，Server 就會回覆 HTTP Status Code 200 並給予新的檔案\n若是沒有更新則 Server 會回覆 304 Not Modified，就繼續拿本地的 Cache 來用\n介紹完了概念後，來補充一些細部的解釋吧～\nCache-Control 最快的連線就是不要連線，透過本地的緩存，減少不必要的成本，這就要透過 Cache-Control 的設定了\nno-cache \u0026amp; no-store  no-cache 表示必須要跟 Server 確認檔案的一致性，不論過期與否，若驗證（ETag）通過，則可直接存取本地緩存 no-store 就更加簡單了，就是禁止在本地儲存任何的緩存，每次的請求都會由 Server 給予完整的回應  public \u0026amp; private  public 表公開資訊，可被緩存，但通常不另外設定 private 表私人資訊，不允許中繼快取（如 CDN）  max-age 表示從請求後開始可緩存的時間（秒）\nHTTP Status 200 OK (form disk cache) 與 304 Not Modified 先來了解什麼是 200 OK (form disk cache) 與 304 Not Modified\n 200 OK (form disk cache)：\n是表示 Browser 沒有跟 Server 確認，就直接使用了本地的 cache 304 Not Modified：\n是表示 Browser 跟 Server 確認 cache 的可用性後再使用  Cache 的更新及作廢 依照上面的機制，當 Client Caching 後就只能等它到期後再更新成 Server 上的內容，但是若是我想要 patch 怎麼辦呢？最簡單的方式就是變更請求的位置\n但如果我們沒有辦法變更呢？很抱歉，只能告訴你，做不到了\u0026hellip;\n所以我們可以設想一下如何才能設計一個魚與熊掌兼得的架構呢？\n其實我們只要混用剛剛所說的就可以了，參考下面的圖例\n我們藉由給予每個不同的資源不同的快取策略，定義 “快取階層”，如此一來，同時達成用戶端快取和快速更新。\n HTML 標記為 no-cache，這表示瀏覽器在每次請求時都會重新驗證文件，如果內容變更，就會拿到最新版本。同時，在 HTML 標記中，我們在 CSS 和 JavaScript 資源的網址中嵌入指紋碼：如果這些檔案的內容變更，網頁的 HTML 也會隨之變更，並將下載 HTML 回應的新副本。 允許瀏覽器和中繼快取 (例如 CDN) 快取 CSS，期限設定為 1 年。請注意，我們可以放心使用 1 年的「遠期期限」，因為我們在檔案名稱中嵌入了檔案指紋碼：如果 CSS 更新，網址也會隨之變更。 JavaScript 期限也設定為 1 年，但是被標記為「private」，也許是因為其中包含了不適合 CDN 快取的使用者私人資料。 快取圖片時不包含版本或唯一指紋碼，期限設定為 1 天。  參考資料  HTTP 快取 - Google Web Developers 循序漸進理解 HTTP Cache 機制 - TechBridge 技術共筆部落格  "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/go-introduction/",
	"title": "Go 介紹",
	"tags": ["go", "golang"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "在一年多以前，開始在社群跟朋友間很常聽到 Go 這個程式語言，也很好奇為什麼它突然聲名大噪，為什麼這麼多人推崇，在做了一些功課以後，近期有個機會可以將 Go 用在實際的專案上，就來稍微的敘述一下心得好了。\n背景 \u0026amp; 理念 Google 開發的一種靜態強型別、編譯型、併發型，並具有垃圾回收功能的開源程式語言，於 2009 年面世，也稱作 Golang。由 Rob Pike \u0026amp; Robert Griesemer \u0026amp; Ken Thompson 共同開發，在短短不到十年的時間已在程式排名中有一席之地了，像是獲選 TIOBE 的 2016 最佳語言\n以下節錄 Rob Pike 在 2012 年的演講中提到的一句話：（https://www.youtube.com/watch?v=bj9T2c2Xk_s）\n Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go's design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components.\n 作者們看到了 Google 在開發上遇到的困境，由於開發環境的變遷：多核處理、網路系統、大規模電腦叢集等等，開發的規模也不同，所以才著手設計這套程式語言。總而言之，Golang 是為了解決實務的軟體工程問題而設計的，而非程式語言上的科研。\n網友也畫了漫畫簡介了 Golang：部落图鉴之Go\n特性 Golang 語言有以下的特性：\n 靜態型別的編譯語言 跨平台 (cross-platform) 全自動的垃圾回收 (garbage collection) 平行處理 (concurrency) 程式風格強制統一 快速編譯 內建開發相關工具 豐富的標準函式庫  Golang 是靜態型別的編譯語言，對於程式設計者來說，這類的語言有軟體工程上的優點，像是可以預先進行語法、型別檢查，對於追蹤錯誤更加方便，編譯語言的效能也會比直譯語言好；在編譯時也可針對不同的平台做編譯，達成跨平台的需求；編譯出二進制執行檔後，可直接執行，不需像傳統部署一樣要上傳多個檔案及伺服器的設定；許多的 web 語言都是跑 single thread，所以會閒置許多系統效能，現在的伺服器幾乎都是多核 CPU 了，而 golang 透過 Goroutine 實現了 concurrency，使用者只要設定最大的 thread 數量，和系統是多少 CPU，run-time 就會幫你處理好剩下的 thread 管理。\n現行服務 \u0026amp; 受歡迎度 Golang 近幾年的成長是大家有目共睹的，像是在 Google 中 Golang 的搜尋也是逐年成長\n在 Stack Overflow 2017 的開發者調查中也是名列前茅\n目前有很多的開源項目使用 Golang 作為核心語言，如：Docker、rkt、Kubernetes、Flynn、deis 等等，更有許多的知名企業也導入了 Golang，如：Google、Facebook、Dropbox 等\n使用考量 在對於 Golang 有初步了解後，就要評估是否適合接下來要導入的專案，畢竟每一個語言都有它適合的場景，牽涉到的可是時間跟金錢，重寫要花費的代價可是非常可觀。\n照上面幾點來看，Golang 初始設計的方向就是為了解決大型軟體架構遇到的問題，以軟體工程為設計目的的程式語言，有快速編譯、嚴格的依賴管理、風格統一、Concurrency 控制，但也缺少了一些常見的特性，像是不用繼承，但也有對應的解決方案，又或者說 Golang 因為工程上的考量而精簡了功能。\n上面提到近期有一個專案可以讓我試用一下 Golang，是一個關於影像處理的 console application，但因為影像處理的大部分工作是交給另一個工具，所以這裡只是間單的 parser 資料並整理 I/O 的資訊。以撰寫程式碼來說，因我比較熟悉的是 PHP，寫 Golang 時不免覺得囉嗦了點，但 golang 風格統一，相較於 C 也簡單得多，很快就可以略懂略懂了。效能的部分，因為這次的功能較簡單，且 bottleneck 都在影像處理的工具上，所以並沒有顯著的差異，但網路上有許多的實驗數據證明這點，待下次在實驗一下了。再來是 Concurrency Control，這也是 Golang 的特色之一。發佈版本時，Golang 透過編譯可直接產生執行檔執行，不需在機器上再安裝其他東西。另外這次沒有測到 web 的部分是比較可惜的。\n結語 在看了這麼多以後，來總結一下，Golang 有一個富爸爸，跟現在成長的速度和社群的蓬勃，前途看好，跟大多數通用型程式語言相比，Golang 更多的是為了解決我們在構建大型系統軟體的過程中，所遇到的軟體工程問題而設計的。這麼講可能會讓人感覺 Golang 非常無趣且工業化，但實際上，在設計過程中就著重於清晰和簡潔，以及較高的可組合性，最後得到的反而會是一門使用起來效率高而且很有趣的程式語言，若是還沒嘗試過的話建議玩玩看喔。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/ffmpeg/",
	"title": "FFmpeg",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/ffmpeg-h264-options/",
	"title": "FFmpeg H.264 編碼器",
	"tags": ["FFmpeg", "H264"],
	"categories": [],
	"series": ["media"],
	"description": "",
	"content": "H.264 / MPEG-4 AVC 是目前最被廣泛被應用的視訊編碼格式，它的壓縮效率比 MPEG-2、MPEG-4、RV40 \u0026hellip;等舊視訊編碼格式還要高許多。\n如果要輸出 H.264 / AVC 視訊編碼，則需要 libx264 編碼器，FFmpeg 的組態設定之中必須有 --enable-libx264 則才可以使用。\nH.264 有多個版本，版本越高壓縮比就越高（對應到 profile）\n碼率控制（Rate control） Rate control 是指控制 每個畫格用了多少個位元 的方法，這將影響檔案大小和品質分布。這裡就先不探討 Rate control 的種類有哪些。\n通常會用下列兩種模式： Constant Rate Factor (CRF)、Two-Pass ABR，若沒有控制輸出大小的需求則使用 CRF 即可\nConstant Rate Factor（CRF） 固定品質指標，而不在意大小；CRF 會得到最佳的 bitrate 分配結果，缺點是你不能直接指定一個目標 bitrate 或是檔案大小。\n設定值範圍為 0 – 51（可能會依照編譯版本而不同），0 為最高品質，預設值為 23，建議的範圍在 18 - 28，17 或 18 接近視覺無損，但在技術上來說並不是無損。\nTwo-Pass ABR（Average Bitrate） 以平均值來說 ABR 與 CBR 相同，但 ABR 允許在 “適當” 的時候使用更好的 bitrate 以取得更好的畫質，但 ABR 是用動態補償的方式來計算畫面的複雜度，也就是說在影片的起始及開頭，或是當畫面不如預期變化的時候則可能會影響到產出。\n所以在 two-pass 的時候，第一次轉檔時會先分析紀錄影片的內容，第二次再依照分析的結果加以轉碼，但相對的就是非常耗時，要是沒有輸出大小的需求，則用 CRF 即可。\nPreset 為選項集合，用來設定編碼速度，相對的也會影響到壓縮比；編碼越快則壓縮比越低。\n一速度遞減排序為：ultrafast、superfast、veryfast、faster、fast、medium（預設）、slow、slower、veryslow、 placebo\nTune 選項 也是為一個集合選項，可針對特定的影片類型微調參數設定值，以獲得更好的品質或壓縮率\n Film：film，用於高解析度電影，降低 deblocking Animation：animation，動畫＆卡通，使用 deblocking 和較多的 reference frames Grain：grain，保留舊影片的顆粒感 Still Image：stillimage，幻燈片效果的影片 Fast Decode：fastdecode，啟用部分禁用的 filter 來加速編碼 Zero Latency：zerolatency，快速編碼＆低延遲 PSNR：psnr，優化 PSNR SSIM：ssim，優化 SSIM  Profile 複合選項，Profile 越好壓縮比也越高，但編碼複雜度相對提升；越好的 Profile 相對啟用的功能也越多，所以對播放硬體的需求也較高\n  Profiles      baseline   main   high    no-8x8dct 1 1     bframes  0     no-cabac 1      cqm  flat flat     weightp  0     Level 複合選項，與解碼器的效能及容量對應，Level 越高需求越高\n  Level     MaxMBPS(MB/s) MaxFS(MBs) MaxDpbMbs(MBs) MaxBR(kbit/s)(Baseline,Main Profiles) Examples for high resolution@ highest frame rate   3.0 40,500 1,620 8,1000 10,000  176×144@172 352×240@120 352×480@60 720×480@30 720×576@25    3.1 108,000 2,600 18,000 14,000  352x288@172 352x576@130 640x480@90 720×576@60 1,280×720@30    4.0 245,760 8,192 32.768 20,000  720x480@172 720x576@150 1,280×720@60 2,048×1,024@30    4.1 245,760 8,192 32,768 50,000  720x480@172 720x576@150 1,280×720@60 2,048×1,024@30    4.2 522,240 8,704 34,816 50,000  720x576@172 1,280×720@140 2,048×1,080@60    Decoded picture buffering 1  capacity = min(floor(MaxDpbMbs / (PicWidthInMbs * FrameHeightInMbs)), 16)     Level 3.0 3.1 4.0 4.1 4.2   MaxDpbMbs 8,100 18,000 32,768 32,768 34,816   自定義 以上說的都是複合指令，若是有需求也可利用 -x264-params 做個別設定\n可參考：\nhttps://ffmpeg.org/ffmpeg-codecs.html#libx264_002c-libx264rgb\n  -I, keyint\n設定 i-frame 間隔，也就是 GOP size\n  -i, --min-keyint\n最小 GOP size\n  -r, --ref\n控制 DPB（Decoded Picture Buffer） 大小，表示 P-frame 參照多少個 frame。預設值為 3，範圍：0 - 16。\n  --scenecut\n配置動態 i-frame 的參考值；x264 的 frame 中會紀錄與參考 frame 的差異，當判斷差異過大時就是場景變更，此時就會插入一個 i-frame 來做紀錄，差異的依據可由設定 scenecut 來做判別，當設為 0 時等同 no-scenecut。\n  --no-scenecut\n停用 adaptive I-frame decision\n  參數優先順序 1  preset -\u0026gt; tune -\u0026gt; \u0026#34;custom\u0026#34; -\u0026gt; profile -\u0026gt; level   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/h264/",
	"title": "H264",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/series/media/",
	"title": "media",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/ffmpeg-common-options/",
	"title": "FFmpeg 常用選項",
	"tags": ["FFmpeg"],
	"categories": [],
	"series": ["media"],
	"description": "",
	"content": "接續著上次的簡介及流程介紹，這次就來聊聊常用到的選項（還偷渡了一點我會用到的 XDD）\n一開始我們先來確認 FFmpeg 的版本 ＆ 內含 Library，這關係到我們能用的功能，好比說我想轉 H.264 的 Codec，那麼我就要先確認我有沒有 libx264 這個函式庫\n1  $ ffmpeg -version   再來我們來複習一下上次說到的指令語法結構：\n1 2 3 4 5  $ ffmpeg [全域選項] \\  {[輸入選項] -i 輸入檔案路徑} \\  [...] \\  {[輸出選項] 輸出檔案路徑} \\  [...]    依照 FFmpeg 的元件來拆解會是下面的樣子：\n1 2 3 4 5 6 7 8  $ ffmpeg -c:v {視訊解碼器} \\  -c:a {音訊解碼器} \\  -f {多工解訊器} \\  -i {輸入檔} \\  -c:v {視訊編碼器} \\  -c:a {音訊編碼器} \\  -f {多工器} \\  {輸出檔}    選擇串流 在上次提到在一檔案進到 FFmpeg 後會先透過 demuxer 讀出各個串流，有可能是 Video 或 Audio，更甚至於是字幕，所以在設定輸入及輸出的時候也要給予相對應的設定；可以透過 -map 來指定串流，又或者是利用 -vn / -an / -sn 來做選擇。\n  -map [輸入檔案索引][:串流識別符]\n挑選輸入串流\n  -vn\n禁用影像輸出\n  -an\n禁用音訊輸出\n  -sn\n禁用字幕輸出\n  另外在某些選項上也可以針對串流去做設定，語法結構為：\n1 2 3 4 5 6 7 8  -選項[:串流類別][:串流索引] [設定值] ------------------ /|\\ | 串流識別符 # 串流類別有 v, a, s, d, t，分別代表了：視訊（Video）、音訊（Audio）、字幕（Subtitle）、資料（Data）、附件（Attachment） # 串流索引是從 0 起算   例如：\n-codec:a libfdk_aac，表示所有音訊用 libfdk_aac 編碼\n主要選項   -y（全域）\n若存在則覆蓋檔案\n  -n（全域）\n若存在則退出\n  -i 檔案路徑（輸入）\n設定輸入的檔案\n  -codec[串流識別符] 編解碼器（輸入/輸出，每一個串流）\n與 -c 同義，設定編解碼器，copy 表示不進行編碼（只用於輸出）\n  -ss 時間戳記（輸入/輸出）\n指定開始時間，格式為：hh:mm:ss[.xxx] 或秒數。\n在輸入時會跳轉到指定時間點並歸零的當前時間戳記。\n   在大多數的格式中並無法精確定位到指定時間，所以 FFmpeg 會跳轉到最接近指定時間 “前” 的可定位點。另外若有轉碼且設置了 -accurate_seek（默認），則定位點到指定時間中間的數據會被轉碼但丟棄掉；如果是複製（copy）模式或設置了 -noaccurate_seek，則數據會被保留\n 在輸出時則會從頭開始解碼，但丟棄指定時間點前的數據。\n  -t 時間戳記（輸入/輸出）\n設定總長，格式為：hh:mm:ss[.xxx] 或秒數\n  -to 時間戳記（輸出）\n寫入到指定時間後就停止，格式為：hh:mm:ss[.xxx] 或秒數\n   -to 和 -t 互斥，-t 的優先權較高\n   -filter[串流識別符] filtergraph（輸出，每一個串流）\n設定使用的 filtergraph 濾鏡\n  -filter_complex filtergraph（輸出，每一個串流）\n設定一個複雜的 filtergraph 濾鏡（多個輸入/輸出）\n  -target 類型（輸出）\n指定輸出類型（vcd、svcd、dvd、dv、dv50），另外類型還可以前綴標記（pal-、ntsc-、film-）來設置更明確的格式。設定格式後會幫你帶入其他的設定（解析度、畫格速率、編碼參數、位元率、緩衝）。\n  -f 檔案格式\n一般來說是不用設置這個選項，因為 FFmpeg 會依照輸入或輸出來做判斷\n  Video 選項   -r[:串流識別符] fps（輸入/輸出，每一個串流）\n設定 framerate\n作為輸入選項時會忽略來源的 fps，強制給予給定的 framerate。\n作為輸出選項時會複製或丟棄 frame 來滿足要求。\n  -s[:串流識別符] WxH（輸入/輸出，每一個串流）\n設定畫布大小，如：320x240\n作為輸入選項時，等同於部分選項的私有設定 -video_size\n作為輸出選項時，等同於 scale 濾鏡\n  -vcodec 編碼器（輸出）\n設定視訊的編碼器，等同 -codec:v\n  -pass[:串流識別符] n（輸出，每一個串流）\n設定 two-pass 的階段。用 two-pass 編碼時，第一次通常會把統計的結果存到一份 log 中，供第二次分析用。\n  -passlogfile[:串流識別符] 前綴（輸出，每一個串流）\n設定 two-pass 的 log 存放位置\n  -vf filtergraph（輸出）\n等同 -filter:v\n  Video 進階選項  -pix_fmt[:串流識別符] 格式（輸入/輸出，每一個串流）\n轉換像素格式，可用 -pix_fmts 指令查看是否支援  Audio 選項   -acodec 編碼器（輸出）\n設定音訊的編碼器，等同 -codec:a\n  -ac[:串流識別符] 聲道數（輸入/輸出，每一個串流）\n設定聲道的數量，預設是輸出與輸入相同\n  編解碼選項（Codec） 從上述的介紹中得知，我們可藉由 -codec 來設定編解碼器，每個編解碼器也會有私有的設定選項，這裡就先列出通用的\n 這裡選項後的括弧表示它可運作的範圍\n   -b 位元率（編碼/視訊/音訊）\n設定串流的 bitrate\n  -bf 整數（編碼/視訊）\n設定 B-Frame 的間隔數，範圍 -1 ～ 16，0 表示禁止，-1 表示交由編碼器決定，預設為 0\n  -bufsize 大小（編碼/視訊/音訊）\n設定緩衝區大小（bit）\n  -maxrate 位元率（編碼/視訊/音訊）\n設定最大流量容許值\n  -minrate 位元率（編碼/視訊/音訊）\n設定最小流量容許值，通常用於 CBR，否則無意義\n  -g 整數（編碼,視訊）\n設定 GOP 的大小，即 IDR-frames（keyframes）最長間格\n  "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/ffmpeg-introduction/",
	"title": "FFmpeg 多媒體框架",
	"tags": ["FFmpeg"],
	"categories": [],
	"series": ["media"],
	"description": "",
	"content": "FFmpeg 為開源的影音處理框架，可幫助我們進行影音的格式轉換、分離、混合、過濾等等，支援格式 也非常的廣泛，也可以在多個作業系統及硬體架構上運作。同時也支援多種函式庫，更增加使用上的彈性，依照需求建立出最適合的工具。\nFFmpeg 包含許多的函式庫\n libavcodec：用來編碼與解碼不同的影音格式 libavutil：一些程式上會用到的函式與資料結構 libavformat：用來處理承載影音串流的多媒體容器 libavfilter：用來進行視訊和音訊的濾鏡處理 libavdevice：用來從不同的裝置輸入多媒體，或是將多媒體輸出至不同裝置 libswscale：用極佳的方式縮放影像，也可以用來轉換色彩空間 libswresample：用極佳的方式處理音訊取樣  還可以支援其他的第三方函式庫，如：libx264、libvpx、libfdk_aac；依照這些函式庫 FFmpeg 提供了許多的工具：\n ffmpeg：Command line tool，用來轉換不同格式的多媒體檔案 ffserver：用於線上廣播的多媒體串流伺服器 ffplay：基於 SDL 和 FFmpeg 函式庫的簡易播放器 ffprobe：簡易的多媒體串流分析工具  安裝 安裝的部分就略過了，官方提供的方式非常多元，可參照官網上的敘述：https://www.ffmpeg.org/，我個人因為用的是 Mac，採用的是 Homebrew 安裝管理\n再來就是重頭戲了～～～\n因為 FFmpeg 的功能非常強大，也涉及一些影音的知識，我這裡就先就操作和流程去說，其他的再慢慢補完：\n語法結構 1 2 3 4 5 6  # 支持多個輸入和輸出，所以 `...` 代表可傳入多個的意思 $ ffmpeg [全域選項] \\  {[輸入選項] -i 輸入檔案路徑} \\  [...] \\  {[輸出選項] 輸出檔案路徑} \\  [...]   運作流程 graph TD; node1[Input file] -- demuxer --\u0026gt; node2[Encoded data packets]; node2 -- decoder --\u0026gt; node3[decoded frames]; node3 -- encoder --\u0026gt; node4[encoded data packets]; node4 -- muxer --\u0026gt; node5[output file]; 用 libavformat 來分離輸入的檔案，再利用 decoder 去解出非壓縮的內容，再透過 filter 過濾，經過壓縮後再混合成新的檔案。\n上述的圖再編碼之前還可以進一步被 filter 處理（使用 libavfilter 函式庫），而 filter 可組成 filtergraphs，filtergraphs 在依照輸入及輸出可分成 Simple filtergraphs \u0026amp; Complex filtergraphs。\nSimple filtergraphs graph TD; node1[decoded frames] -- simple filtergraph --\u0026gt; node2[filtered frames]; node2 -- encoder --\u0026gt; node3[encoded data packets]; Simple filtergraphs 透過 -filter 來做設定，以下是一個 Simple filtergraphs 的範例：\ngraph TD; node1[input] --\u0026gt; node2[deinterlace]; node2 --\u0026gt; node3[scale]; node3 --\u0026gt; node4[output]; Complex filtergraphs graph TD; node1[input 0] --\u0026gt; node4[complex filter graph]; node2[input 1] --\u0026gt; node4; node3[input 2] --\u0026gt; node4; node4 --\u0026gt; node5[output 0]; node4 --\u0026gt; node6[output 1]; Complex filtergraphs 透過 -filter_complex 這個全域選項來做設定\nStream Copy 再來我們聊聊 Stream copy，有時候我們並無意改變 Codec，只想改變 video 的 container，那麼我們可以用 -code copy 來做設定，但同時也意味著沒有經過解碼及編碼階段，也不會有 filter 的處理。\ngraph TD; node1[input file] -- demuxer --\u0026gt; node2[encoded data packets]; node2 -- muxer --\u0026gt; node3[output file]; 參考資料 ffmpeg Documentation\nFFmpeg - 泛用影音轉換工具 - Mobile01\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/owasp/",
	"title": "OWASP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/owasp-2017/",
	"title": "OWASP Top 10 2017",
	"tags": ["OWASP"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "這禮拜一去參加了 OWASP 2017 的研討會，其中提到了新發佈的 OWASP Top 10 2017版；先回頭來談一下什麼是 OWASP，在開發系統時，除了功能以外，安全也是必須要著重且注意的，在快速開發的過程中，常常會沒有兼顧到安全這塊；對於部分各戶來說，在還未出包之前大概也不會感覺到資安的重要；OWASP 就統整了十大弱點排名（當然啦～不是只有這十個需要重視）， 最近的一次正式更新是在 2013 年，在這過程中資訊的進步很快，排名也略有變動。\n在研討會中也提到了最新的 OWASP Top 10 2017，與 2013 年比較第一名依舊是 Injection，第二名是身份驗證；然而新版的因考慮了現在的系統採用了許多的 API 讓前後端分離，也搜集了實際企業的 Log 數據，可以從排名中看出都跟最近流行的微服務有關。\nTop 1: Injection Injection（注入攻擊）\n將不安全的數據傳送到解析器中，當作指令（Command）或查詢（Query），產生如 SQL Injection、LDAP Injection 等等的 Injection 缺陷。攻擊者就可以用惡意的資料欺騙解析器，進而達到竄改資料或執行非預期的指令。\nTop 2: Broken Authentication and Session Management Broken Authentication and Session Management（無效身分認證和 Session 管理）\n許多系統常會需要身份驗證才能操作，但要是導入方式不正確，反而可能被有駭客取得駭客取得密碼、金鑰、Session 令牌，用來冒用其他用戶身份。\nTop 3: Sensitive Data Exposure Sensitive Data Exposure（敏感資料外洩）\n許多系統常會牽涉到一些敏感資料，如個人資料、金融資訊、醫療保健數據等等，若是對資料的保護不足，就可能被駭客取得，進而造成身份偽造、盜竊等行為，固對這些敏感數據應做額外的加密保護，不論是在傳輸的過程中、儲存、瀏覽器瀏覽的過程中都是。\nTop 4: XML External Entity(XXE) XML External Entity(XXE)（XML外部處理器漏洞）\nXXE 漏洞發生在程式解析 XML 輸入時，沒有禁止外部實體的載入。在以 XML 為基礎的服務中若沒有管控權限，直接接受 XML 的請求，就有可能被惡意的 XML 文件影響，導致敏感數據被竊取、遠程代碼執行、取得機器上檔案的存取權、DoS（阻斷式服務）、掃描內網等等。\nTop 5: Broken Access Control Broken Access Control（無效的存取控管）\nInsecure Direct Object References \u0026amp; Missing Function Level Access Control\n是由 2013 年的 Insecure Direct Object References 和 Missing Function Level Access Control 合併而來；系統需對用戶的身份做適當的存取管控，駭客會利用控管的漏洞去存取沒有經過授權的功能或察看敏感資料、修改使用者數據、更改訪問權限等。\nTop 6: Security Misconfiguration Security Misconfiguration（不安全的組態設定）\n一般來說都是開發者使用了不安全的設定值，像是 HTTP header、AWS S3 bucket 權限控管等等，系統的設定也要跟版本和漏洞配合，確保系統安全無虞。\nTop 7: Cross-Site Scripting(XSS) Cross-Site Scripting(XSS)（跨站腳本攻擊）\n當應用程式未將使用者提供的資料先審核或進行內容編碼，就直接將資料傳輸到網路瀏覽器，即可能發生 XSS 問題。XSS 能讓攻擊者直接在受害者的網路瀏覽器上執行 Script，攻擊者便可以綁架用戶的 Session 或竄改網站內容等。\nXSS 一直是是網站攻擊排行榜上有名的，有太多種可能性可以執行 JavaScript，只要有一點機會就會讓駭客有機可趁。\nTop 8: Insecure Deserialization Insecure Deserialization（不安全的反序列化漏洞）\n當系統收到惡意的序列化物件時（如 JSON、XML），在反序列化時會出現不安全缺陷，駭客可透過這個過程竄改變數或更甚於影響到程式執行。\nTop 9: Using Components with Known Vulnerabilities Using Components with Known Vulnerabilities（使用已有漏洞的元件）\n現今的開發常會用到現成的元件、套件、Framework，要時常確認現在的版本有無缺陷或更新。\nTop 10: Insufficient Logging \u0026amp; Monitoring Insufficient Logging \u0026amp; Monitoring（紀錄與監控不足風險）\n完整 Log 紀錄及監控能夠讓我們更了解系統在運行的過程中是否正常，是否有駭客入侵或竄改系統的紀錄，在會議中也提到，依數據顯示：大多數的缺陷被檢測出的時間超過 200 天，顯示了紀錄與監控不足。\n同場加映： Cross-Site Request Forgery(CSRF)（跨站請求偽造）\n跨站請求攻擊，簡單地說，是攻擊者通過一些技術手段欺騙用戶的瀏覽器去訪問一個自己曾經認證過的網站並執行一些操作（如發郵件，發消息，甚至財產操作如轉帳和購買商品）。由於瀏覽器曾經認證過，所以被訪問的網站會認為是真正的用戶操作而去執行。這利用了 Web 中用戶身份驗證的一個漏洞：簡單的身份驗證只能保證請求發自某個用戶的瀏覽器，卻不能保證請求本身是用戶自願發出的。\n另外若是對於 OWASP Top 10 有任何的建議或疑問都可以到官方的 GitHub，上面也紀錄了歷年來的版本 - https://github.com/OWASP/Top10\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/gps-nmea/",
	"title": "GPS 資料格式",
	"tags": ["GPS", "NMEA"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "什麼是 NMEA file ？\n美國國家海洋電子協會 (National Marine Electronics Association，NMEA) 制定了 GPS 協定標準規格，NMEA 0183 的資料格式中記錄了座標、方位、速度、衛星有效數量等等的資訊。\n資料格式 1  $ttsss,d1,d2,....   以 $ 為起始，ttsss 表示識別符，後面接上以 , 分隔的資料資料區塊，最後由 CR/LF （換行）為結尾。\n識別符 NMEA 定義了多種 identifier，這裡列出我比較會有用到的：\nGPRMC, Recommended Minimum Navigation Information 推薦的最小定位資訊，資料格式為：\n \u0026lt;1\u0026gt; UTC 時間，格式：hhmmss.ss（時分秒）\n\u0026lt;2\u0026gt; 定位狀態，A=有效定位，V=無效定位\n\u0026lt;3\u0026gt; 緯度 ddmm.mmmm（度分）格式（位數不足則補 0）\n\u0026lt;4\u0026gt; 緯度半球 N（北半球）或 S（南半球）\n\u0026lt;5\u0026gt; 經度 dddmm.mmmm（度分）格式（位數不足則補 0）\n\u0026lt;6\u0026gt; 經度半球 E（東經）或 W（西經）\n\u0026lt;7\u0026gt; 地面速率（000.0~999.9節，位數不足則補 0）\n\u0026lt;8\u0026gt; 地面航向（000.0~359.9度，以真北為參考基準，位數不足則補 0）\n\u0026lt;9\u0026gt; UTC 日期，ddmmyy（日月年）格式\n\u0026lt;10\u0026gt; 磁偏角（000.0~180.0度，位數不足則補 0）\n\u0026lt;11\u0026gt; 磁偏角方向，E（東）或W（西）\n\u0026lt;12\u0026gt; 模式指示（僅 NMEA0183 3.00 版本輸出，A=自主定位，D=差分，E=估算，N=資料無效）\n 經緯度轉換 NMEA 紀錄格式為 ddmm.mmmm\n 以 4124.8963 為例\n先除 100 得到 41.248963\n將小數點後面運算 除60 乘100 =\u0026gt; 0.248963*100/60 = 0.103303\n再加上先小數點前的值 41+0.103303=41.103303\n這樣就可在 Google Map 中使用\n 若要轉換成 Google Map 可用的格式可參考以下程式碼\n1 2 3 4 5 6 7 8 9 10 11 12 13  // Javascript Code function formatGPS(number, quadrant) { if (quadrant == \u0026#39;W\u0026#39;) { quadrant_value = -1; } else if (quadrant == \u0026#39;S\u0026#39;) { quadrant_value = -1; } else { quadrant_value = 1; } return (((number/100).toString().split(\u0026#34;.\u0026#34;)[0])*1 + (\u0026#34;0.\u0026#34; + (number/100).toString().split(\u0026#34;.\u0026#34;)[1])*100/60) * quadrant_value; }   GPGGA, Global Positioning System Fix Data. Time, Position and fix related data for a GPS receiver GPS 定位資訊，資料格式為：\n \u0026lt;1\u0026gt; UTC時間，hhmmss.sss（時分秒）格式\n\u0026lt;2\u0026gt; 緯度 ddmm.mmmm（度分）格式（位數不足則補 0）\n\u0026lt;3\u0026gt; 緯度半球 N（北半球）或 S（南半球）\n\u0026lt;4\u0026gt; 經度dddmm.mmmm（度分）格式（位數不足則補 0）\n\u0026lt;5\u0026gt; 經度半球 E（東經）或 W（西經）\n\u0026lt;6\u0026gt; GPS 狀態：0=未定位，1=非差分定位，2=差分定位，6=正在估算\n\u0026lt;7\u0026gt; 正在使用解算位置的衛星數量（00~12）（位數不足則補 0）\n\u0026lt;8\u0026gt; HDOP 水平精度因數（0.5~99.9）\n\u0026lt;9\u0026gt; 海拔高度（-9999.9~99999.9）\n\u0026lt;10\u0026gt; 高度單位，M 表公尺\n\u0026lt;11\u0026gt; 大地橢球面相對海平面的高度（-999.9到9999.9）\n\u0026lt;12\u0026gt; 高度單位，M 表公尺\n\u0026lt;13\u0026gt; 差分 GPS 數據期限（RTCM SC-104），最後設立 RTCM 傳送的秒數量\n\u0026lt;14\u0026gt; 差分參考基站標號，從0000到1023（位數不足則補 0）\n\u0026lt;15\u0026gt; checksum 校驗\n GPGSV, Satellites in view 取目前可見到的衛星資訊，資料格式為：\n \u0026lt;1\u0026gt; 收到 GPS 訊息的總數\n\u0026lt;2\u0026gt; 收到 GPS 訊息的編號\n\u0026lt;3\u0026gt; 可見衛星的總數，00 至 12\n\u0026lt;4\u0026gt; 衛星編號，01 至 32\n\u0026lt;5\u0026gt; 衛星仰角，00 至 90 度\n\u0026lt;6\u0026gt; 衛星方位角，000 至 359 度\n\u0026lt;7\u0026gt; 訊號雜訊比（C/No），00 至 99 dB；無表未接收到訊號\n\u0026lt;\u0026hellip;\u0026gt; 重複 4 ~ 7，最多四組（用 [] 包）\n\u0026lt;8\u0026gt; Checksum 校驗\n GPGSA, GPS DOP and active satellites 當前衛星資訊，資料格式為：\n \u0026lt;1\u0026gt; 模式 ：M=手動，A=自動\n\u0026lt;2\u0026gt; 定位型式 1=未定位，2=二維定位，3=三維定位\n\u0026lt;3\u0026gt; 到 \u0026lt;14\u0026gt; 01 ~ 32 表天空使用中的衛星編號，最多可接收12顆衛星資訊\n\u0026lt;15\u0026gt; PDOP 位置精度因數（0.5~99.9）\n\u0026lt;16\u0026gt; HDOP 水平精度因數（0.5~99.9）\n\u0026lt;17\u0026gt; VDOP 垂直精度因數（0.5~99.9）\n\u0026lt;18\u0026gt; Checksum 校驗\n 附加資料 G-Sensor 可幫助 GPS 航位推算，也可記錄當車輛碰到不同事件時所承受的力道\nGSENSORD 部分行車記錄器中所存的 NMEA file 會紀錄 G-Sensor 的值，格式如下：\n \u0026lt;1\u0026gt; X 軸 G 值\n\u0026lt;2\u0026gt; Y 軸 G 值\n\u0026lt;3\u0026gt; Z 軸 G 值\n "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/nmea/",
	"title": "NMEA",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/seo/",
	"title": "SEO",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/seo-basic/",
	"title": "淺談 SEO",
	"tags": ["SEO"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "SEO 是什麼呢？它的全稱是 Search Engine Optimization（搜尋引擎優化）。\n要如何優化呢？其實就是想辦法讓各家的搜尋引擎看懂你的網站；當然內容正確是基本的，搜尋引擎就像一個圖書館一樣，當書目很大量時就得依靠索引、關鍵字等等的輔助去找到書籍，依照大綱、標題等等的去找到正確的內容。再來就是要針對各家的演算法去做強化，但不建議過度針對演算法優化，把內容做好＆標籤打對才是基本功。\n網路上也有不少的系列文可以讓大家更了解 SEO，這裡就針對我所做的優化來敘述。\n內容為王  製作網站的目的是什麼？用戶到你的網站的目的是什麼？當內容吸引人，品質好，訪客就會在網站內多停留幾秒，也會吸引到更多的人來，其餘的優化都不如內容來得更重要。 關鍵字，盡量利用常見的 keyword 以利訪客或搜尋引擎 parser 標籤運用：把關鍵字放在 Title、H1、H2、URL 等等  UI / UX  讓用戶有更好的體驗，這範圍涵蓋的很廣，影響到的不只有用戶的感覺，也影響到 SEO 的排序，像是網站速度＆內容的呈現都是，但是切記不要本末倒置，搜尋引擎會不斷的更新演算法以找到更好用戶體驗的網站，所以一昧地去迎合當前的演算法是治標不治本的，反倒還有可能被服務提供商封鎖。 網站速度：資源壓縮，如圖檔＆JS 等等的都可以先壓縮成適當的大小，可以增加載入速度及提升用戶體驗，有效降低跳出率。 Responsive Web，可以針對不同的用戶給予適當的 UI。  HTTPS  近幾年 Google 在極力大推網路安全，相對的也會同時反應到 SEO 上。 什麼是 HTTPS 呢？是表示網站有沒有裝 SSL，若是有的話在瀏覽器上就會出現綠色勾勾，在 HTTP 的傳輸之中是沒有經過加密的，但 HTTPS 就不同了，HTTPS 會經過加密保護，雖然不是絕對安全，但就像上了鎖一樣，多個防護。 那麼我們有了 HTTPS 還需要注意什麼呢？首要的當然是 301 轉址，畢竟都用了 HTTPS 也希望用戶都是用較安全的方式，也要告訴各搜尋引擎我們搬家了。  網站地圖  在我們製作玩內容以後，當然會希望可以給人知道我們更新了什麼，甚至畫出地圖，讓人可以知道我們葫蘆裡有哪些藥，那我們就可以透過以下的方式告訴搜尋引擎我們有哪些內容： 可藉由 SiteMap 告訴搜尋引擎我們的網站內容架構，可避免爬蟲沒有讀到網頁的完整內容。 atom.xml 提供動態消息給用戶或搜尋引擎 robots.txt 用來跟搜尋引擎溝通的文件  結構化數據標記 為了讓電腦也能看得懂我們所寫的內容，我們可以藉由 結構化標記 來讓搜尋引擎知道所代表的涵意，而標記有很多方法，像是 FB 用的是 Open Graph，而 Google 所用的是 JSON‐LD\nAMP AMP 是由 Google 所提出的 Accelerate Mobile Pages，可讓網頁速度大幅上升，改善使用者體驗\nPWA PWA 全名是 Progressive Web App，目標是讓 Web 逐步地擁有 APP 的優點，徹底改善用戶體驗\n各家評測數據加強 也可藉由線上的服務幫我們的網站健檢\n測試行動網站效能 - Google\n行動網站相容性測試 - Google\nPageSpeed Insights - Google\nGoogle Search Console\nSEO Site Checkup\nWebsite Grader\n參考資料 SEO教學系列\nHarris先生 – SEO 基礎教學\n搜尋引擎最佳化指南（官方釋出文件）\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/cdn/",
	"title": "CDN",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/cloudflare/",
	"title": "CloudFlare",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/godaddy-to-cloudflare/",
	"title": "CloudFlare 代管 GoDaddy DNS",
	"tags": ["CDN", "SSL", "GoDaddy", "CloudFlare"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "前一陣子把 GoDaddy 所購買的 Domain 搬到 CloudFlare 代管，主要是看上免費的 CDN 和 SSL，設定上也很方便\n新增站台 註冊後，點選畫面的右上角「Add Site」來新增站台吧\n在 CloudFlare 掃描完成後，會複製你現有的設定，方便接下來的作業，確認沒問題以後就可以下一步了\n方案的部分我選擇免費的，裡面就已含有 SSL 和 CDN 的功能了\n接下來就是要從 GoDaddy 移轉出來；CloudFlare 會要求將 Nameservers 改成它所給的\n我原本是 GoDaddy，所以要回到 GoDaddy 去改 Nameservers 的設定\n設定都完成後，需要等待一段時間才會生效，可能要數小時甚至是一天\nSSL 到 Crypto 頁面，SSL 預設是 Flexible SSL，不需額外設定，所以當連到網站的時候前面的 protocol 可直接用 https，就會拿到綠色小勾勾徽章 (以為你在打電玩喔\u0026hellip;暈～)，若是希望可以幫你把網站都導向 https 的話，可藉由 Page Rules 頁面做設定。\n加速 到 Speed 頁面，可以試試將 Auto Minify 的功能啟用，會幫忙壓縮檔案\nCaching Always Online 顧名思義就是會保持網站在線，CloudFlare 會定期來網站更新確保資料保持最新的，這同時也會增加網站負荷\nCDN 在設定 DNS 的頁面中，當橘色的雲出現表示有 CDN，但因為真實的位置會被藏在 CDN 之後，所以像是 FTP、SSH 之類的服務不要開啟 CDN 喔。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/godaddy/",
	"title": "GoDaddy",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/ssl/",
	"title": "SSL",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/mac/",
	"title": "mac",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/reinstall-macos/",
	"title": "重新安裝 macOS",
	"tags": ["mac"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "最近換了新的工作，因舊的 mac 已不敷使用，只好將它脫手買一台最新最潮的 MacBook Pro 了 (不知道是該難過還是高興\u0026hellip;)\n回到正題，其實 Mac 不太需要重灌，舊的 MacBook Air 也用了好幾年，這中間也都沒有重灌過，不過若是像我一樣是想要賣人，那當然要清乾淨了 ( 免得不小心流出什麼 )\n用內建磁區開機 在 Mac 出廠時都會有一個隱藏的磁區是可以用來還原系統。\n按下電源按鈕啟動 Mac 後，馬上按下組合鍵 Command（⌘）-R，等看到 Apple 標誌後放開，就可以看到以下畫面：\n清除啟動磁碟（如需要）##  在「macOS 回復」的工具程式視窗中，選擇「磁碟工具程式」，然後按一下「繼續」。 在「磁碟工具程式」的側邊欄中，選擇裝置或磁碟。 按一下「清除」按鈕或標籤頁。 填妥下列欄位：   名稱：輸入磁碟的名稱，如「Macintosh HD」。 格式：選擇 Mac OS 擴充格式（日誌式）或 APFS。 架構（如有）：選擇「GUID 分割區配置表」。  按一下「清除」開始清除磁碟。 完成後，結束「磁碟工具程式」，返回工具程式視窗。現在就可以安裝 macOS 了。  重新安裝 在工具程式視窗中選擇「重新安裝 macOS」，接下來就下一步下一步就完成了\n進階 製作開機隨身碟 (待補，允許我富奸一下)\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/nginx-with-php7/",
	"title": "CentOS 7 上安裝與設定 Nginx + PHP7",
	"tags": ["MacOSX", "git"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "之前在工作上幾乎都是採用 Apache，前一陣子常聽到同事說 Nginx，但我卻沒有實際用過，趁這這次試用 GCP，也來試試看 Nginx\n 注：以下的環境是在 GCE (Google Compute Engine) + CentOS7 上完成。\n 安裝 Nginx 要在 yum 中增加 Nginx，需手動加入 repo 設定，這樣就可以透過 yum 安裝了\n1 2  # 讓 yum 能找到 nginx $ vim /etc/yum.repos.d/nginx.repo   不同的 OS 有不一樣的設定，以下是我的設定 (CentOS7)，其中的 $releasever 改成 7\n1 2 3 4 5  [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1   設定好了以後確認版本 (我的版本是 1.12.1)\n1  $ yum info nginx   安裝 nginx\n1  $ sudo yum install -y nginx   啟用 nginx \u0026amp; 設定開機時啟動\n1 2  $ sudo systemctl start nginx $ sudo systemctl enable nginx   再來就可以試試看可不可以連線啦～成功的話就會看到以下畫面\n安裝 PHP7 因 CentOS 裡的 yum 沒有收錄 PHP，所以自行加入 PHP 7.1 的套件源，這裡就先安裝 webtatic 的 repo，再透過 yum 安裝 PHP\n1 2 3 4 5 6  # epel $ sudo rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # webtatic $ sudo rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm # PHP $ sudo yum install -y php71w-cli php71w-fpm php71w-common php71w-pdo php71w-mbstring   啟用 php \u0026amp; 設定開機時啟動\n1 2  $ sudo systemctl start php-fpm $ sudo systemctl enable php-fpm   確認安裝 \u0026amp; 查詢版本\n1  $ php -v   設定 Nginx 和 PHP7 設定 Nginx 可支援 PHP，在需要的服務中加上以下片段，以我的需求是希望全部都支援 PHP，故加在全域的 server 區塊中：\n1  $ sudo vim /etc/nginx/nginx.conf   1 2 3 4 5 6 7  location ~* \\.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; }   再來就是設定 PHP-FPM\n1  $ vim /etc/php-fpm.d/www.conf   1 2  user = nginx group = nginx    Nginx Server 啟動所使用的使用者 CentOS 預設用 nginx\n 都設定完成後就可以重啟啦～\n1 2  $ sudo systemctl restart php-fpm $ sudo systemctl restart nginx   Nginx 的預設目錄是 /usr/share/nginx/html，在目錄下建一個 index.php 測試是否可以正常運行\nVirtual Host Virtual Host 設定放在 /etc/nginx/conf.d/*.conf\ntroubleshooting 2017-07-21\n在建置新的 GCE 時遇到 html \u0026amp; php 都可以正常執行，但是讀取 mp4 檔時會吐出 13: Permission denied\n後來查到是因為 SELinux，但我是測試用的就先果斷關閉了\n1  $ vim /etc/sysconfig/selinux   把 SELINUX=enforcing 改成 SELINUX=disabled，改完以後重開就可以了\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/categories/gcp/",
	"title": "GCP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/git/",
	"title": "git",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/macosx/",
	"title": "MacOSX",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/gce/",
	"title": "GCE",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/gcp/",
	"title": "GCP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/start-gcp-and-gce/",
	"title": "開始動手做吧～ 在 GCP 上建立自己的虛擬主機",
	"tags": ["GCP", "GCE"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "最近申請了 GCP 上的帳號，首年免費試用，且送 300 美金，立馬開一台來玩玩啊。上面也有免費的機器可以使用，在盤算著是否可以把 AWS 上一些小的測試服務搬過來。\nGCP 試用服務 第一年免費獲得 $300 美元的試用額度，當 12 個月後或用完 $300 美元試用額度後結束試用，若是沒有用完，這筆金額將在 12 個月後作廢。Google Cloud Platform 主控台頂端會顯示剩餘的試用額度和天數。\nGCP 永久免費服務  Google Compute Engine   每個月 1 台 f1-micro VM (限定 US regions，除 Northern Virginia：us-central1、us-west1、us-east1) 每個月 30 GB 硬碟 \u0026amp; 5 GB 快照 每個月 1 GB 的網路出口流量 (除了中國和澳洲)   Google Cloud Datastore   1 GB storage 50,000 reads, 20,000 writes, 20,000 deletes   Google Cloud Storage   每個月 5 GB of Regional Storage (US regions only) 5000 Class A Operations per month 50000 Class B Operations per month 1 GB network egress from North America to all region destinations per month (excluding China and Australia)   Google Cloud Functions   2 million invocations per month (includes both background and HTTP invocations) 400,000 GB-seconds, 200,000 GHz-seconds of compute time 5 GB network egress per month  這裡只介紹了部分的服務，若是有興趣的可以參考 GCP 完整的介紹\nhttps://cloud.google.com/free/docs/always-free-usage-limits/\n了解完方案後，就可以開始建立自己的專案啦～\n建立自己的虛擬主機 建立專案 點選上方功能列 → 選擇新增專案填 → 寫專案名稱\n建立 VM 執行個體 選擇剛建立的專案 → 進入 Compute Engine → VM 執行個體 → 建立\n區域：可選擇您所在的區域，像我因為要開免費的機器，所以選擇 us-west1\n費率：右方可以估算您目前開的機器大概會花費多少\n若是是 WEB server 記得要開防火牆\n連線 VM 建立以後就要要連上去啦～我在這裡是用 SSH 的方式去連線。\n方法是：到 Compute Engine → 設定中繼資料 → SSH 金鑰 → 填入你的 SSH public key\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/remove-ds-store/",
	"title": "刪除 .DS_Store 隱藏檔",
	"tags": ["MacOSX", "git"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "最近新買了一台 NAS，在連線的時候常常會發現多了 .DS_Store 這個隱藏檔，平常在 Mac 上倒是無所謂，但是出現在 NAS 裡就覺得煩人了\nDS_Store .DS_Store (Desktop Services Store) 是一種 Mac OS X 作業系統所創造的隱藏文件，目的在於存貯目錄的自定義屬性，例如文件們的圖標位置或者是背景色的選擇。\n刪除 DS_Store 刪除當前目錄下的 .DS_Store 檔案（包含子目錄）：\n$ find . -name \u0026quot;.DS_Store\u0026quot; -depth -exec rm {} \\; 刪除系統上所有 .DS_Store 檔案：\n$ sudo find / -name \u0026quot;.DS_Store\u0026quot; -depth -exec rm {} \\; 自動產生 DS_Store 關閉系統自動產生 .DS_Store 的服務\n$ defaults write com.apple.desktopservices DSDontWriteNetworkStores true 恢復自動產生 .DS_Store 的服務\n$ defaults delete com.apple.desktopservices DSDontWriteNetworkStores Git \u0026amp; .DS_Store 另外在使用 git 時也會遇到 .DS_Store 追蹤，這裡也記錄一下解法\n可使用 git rm -f 來移除掉特定的檔案\n$ git rm -f *.DS_Store "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/aws/",
	"title": "AWS",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/gcp-vs-aws/",
	"title": "雲端 PK - AWS &amp; GCP",
	"tags": ["AWS", "GCP"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "近年來雲端平台的服務應該大家都不陌生吧～它讓我們可以將維護與建置的工作交付給雲端平台去處理；雲端化以後 IT 維護改由雲端供應商負責，讓我們能花更多的專注力在創新研發上，還能加速部署與模型的建置，使得產品業務更靈活。\n那麼，到底該怎麼挑選適合自己公司的雲端？先來基礎複習一下，主要的三種雲端服務類型 IaaS（Infrastructure as a Service，基礎設施即服務）、PasS（Platform as a Service，平台即服務）、SaaS（Software as a Service，軟體即服務），各家平台在服務上也略有不同：\n該選哪朵雲？ 基礎建設     AWS GCP     地理區域數量 16 regions, 42 zones 9 regions, 27 zones   未來擴點 3 regions 8 regions, 20 zones   Taiwan 有無 regions X V   Link https://aws.amazon.com/tw/about-aws/global-infrastructure/ https://cloud.google.com/about/locations/    機器類型 \u0026amp; 運算能力 GCP 可自訂機器類型，但價錢來說差不多\n計費方式  GCP 以分計費，提供免費服務 (特定機器) AWS 以時計費   試算工具\nAWS：http://calculator.s3.amazonaws.com/index.html\nGCP：https://cloud.google.com/products/calculator/\n 服務項目  AWS 種類玲琅滿目 GCP 服務較少  服務對照     AWS GCP     雲端虛擬伺服器 Amazon EC2 Google Compute Engine   無伺服器 AWS Lambda Google Cloud Functions   隔離雲端資源 Amazon Virtual Private Cloud (VPC) Google Cloud Virtual Network   雲端儲存 Amazon S3 Google Cloud Storage   關聯式資料庫 Amazon RDS Google Cloud SQL   NoSQL Amazon DynamoDB Google Cloud Bigtable   CDN AWS Cloudfront Google Cloud CDN   監控 Amazon CloudWatch Google Cloud Monitoring and Google Cloud Logging   權限管理 AWS Identity and Access Management (IAM) Google Cloud Identity \u0026amp; Access Management (Cloud IAM)   DNS Amazon Route 53 Google Cloud DNS    結語 大多數的人聽到雲端，第一個想到的大多都是 AWS，但目前各家雲端競爭激烈，除了上述介紹的以外還有 MS 的 Azure 等，各家也不斷的在推出新的服務及費率，也或許不會只採用一家的服務，建議還是依照自己的需求選擇自己合適的服務。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/http2/",
	"title": "http2",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/https/",
	"title": "https",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/tcp/",
	"title": "TCP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/tls/",
	"title": "tls",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/about-hyper-text-transfer-protocol/",
	"title": "簡介 HTTP &amp; HTTPS &amp; HTTP2 協定",
	"tags": ["http", "https", "http2", "TCP", "ssl", "tls"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "科技來自於人性，知識的傳遞原本是透過書本或口述，但是當網路出現後，人們想要在上傳遞資訊，就得要制定出一些規則，經過不斷修改，最後總結成了一個協定，把它命名為 HyperText Transfer Protocol。\nHTTP 一種網路傳輸協定，全名是：HyperText Transfer Protocol，設計初衷是為了傳輸 HTML，中間也推出了數個版本，現今最被廣泛使用的是 HTTP1.1。\nHTTP 進程   HTTP/0.9：已過時。只接受GET一種請求方法，沒有在通訊中指定版本號，且不支援請求頭。由於該版本不支援POST方法，因此用戶端無法向伺服器傳遞太多資訊。 HTTP/1.0：這是第一個在通訊中指定版本號的HTTP協定版本，至今仍被廣泛採用，特別是在代理伺服器中。 HTTP/1.1：持久連線被預設採用，並能很好地配合代理伺服器工作。還支援以管道方式在同時傳送多個請求，以便降低線路負載，提高傳輸速度。  ※ 引述自 維基百科\n HTTP \u0026amp; TCP HTTP 是基於 TCP 協定，由 Client 發起，預設走 80 Port。\n在網路分層中由上而下依序是應用、表現、會議、傳輸、網路、鏈結、實體， TCP 是傳輸層協定，HTTP 是應用層，也就是說這是不一樣的東西，TCP 是解決數據如何在網路傳輸，HTTP 是解決如何包裝數據。\nHTTP keep-alive 在 HTTP/1.0 的時候預設的方式是沒有 keep-alive，每一次的連線都是獨立的，在 HTTP/1.1 的時候 keep-alive 是預設開啟的，當多個 request 到同一台時會使用同一個 TCP 連線來傳送和接收，因開關 TCP 連線是有時間成本和 CPU 成本的，如此一來可獲得低網路阻塞和優化效能等等的好處。\nWhy HTTPS? 資訊安全無疑是近幾年討論的話題之一，不論是企業或是個人都需要“保密防諜”，且在 Chrome 56 開始會將網頁的安全資訊直接顯示在網址列，綠色勾勾就跟一個認證一樣，而後 Firefox 51 也跟進這個機制。\nHTTPS 全名是：Hyper Text Transfer Protocol over Secure Socket Layer，是 Netscape 在 1994 年創建，簡單來說 HTTPS 就是 HTTP 的加強版，在 HTTP 上增加了 SSL/TLS 的協定。原本在 HTTP 上的傳遞是明碼的，不加密的狀態下可能有幾項風險：\n 竊聽風險（eavesdropping）：第三方可以獲知通信內容。 篡改風險（tampering）：第三方可以修改通信內容。 冒充風險（pretending）：第三方可以冒充他人身份參與通信。  所以就基於 HTTP 再加上了加密的協議，SSL/TLS 協議是為了解決這三大風險而設計的，希望達到：\n 所有信息都是加密傳播，第三方無法竊聽。 具有校驗機制，一旦被篡改，通信雙方會立刻發現。 配備身份證書，防止身份被冒充。  SSL \u0026amp; TLS SSL 全名：Secure Sockets Layer，是由 NetScape 所設計，經過了多次的修改而廣泛被應用，之後 IETF 將 SSL 進行標準化，並改名為 TLS，全名為：Transport Layer Security。\n對稱加密 \u0026amp; 非對稱加密 \u0026amp; HASH  對稱加密：加密和解密使用同一個金鑰的加密演算法。 非對稱加密：需兩個金鑰來進行加密和解密，分別是公鑰 (public key) 和私鑰 (private key)。 HASH：也稱為雜湊。MD5雜湊演算法可以將任意長度的資料經由運算之後，得到一組固定長度為 128 位元 (32 個十六進制數字) 的結果，我們可以使用這個結果當作檢查碼 (Checksum)。  運作原理 用對稱加密來加密網頁，用非對稱加密來保護對稱加密的金鑰，這樣互補了兩個演算法的缺點。那麼如何保證非對稱加密的公鑰不被篡改呢？ 只要將公鑰放在數位證書中，只要證書是可信的，公鑰就是可信的。因此，SSL/TLS協議的基本過程是這樣的：\n 客戶端向伺服器端要求並驗證非對稱加密算法的公鑰。 雙方協商生成對稱加密算法的 “對話密鑰”。 雙方採用對稱加密算法和它的 “對話密鑰” 進行加密通信。  上面過程的前兩步，又稱為 “握手階段” (handshake)。\n感覺越寫越多，但這篇只是淺談，所以先講到此，有機會再開一篇來細說。\nWhy HTTP2? 前面說了 HTTP \u0026amp; HTTPS 通訊協定是全球資訊網 (WWW) 的基礎，在 Internet 上佔了很大一部分，這幾十年網路生態的改變，成長之快，數量之多，任何一點點的效能速度都足以產生巨大影響。在這久未更新的協定中缺點也就越來越明顯了。以下有幾個參考可以觀察出 HTTP2 在速度上的優異：\n Akamai：HTTP1.1 VS HTTP2 HTTP/2 TECHNOLOGY DEMO  HTTP2 前面說了 HTTP \u0026amp; HTTPS 通訊協定是全球資訊網 (WWW) 的基礎，而HTTP2 是自 1999 年 HTTP1.1 以來最重要的一次升級，主要目的是為了改善網頁的下載速度， 目前各大瀏覽器包括 Chrome、Safari、Firefox、IE/Edge 都已經支援 HTTP2。\n隨著網頁的內容越來越複雜，有時候甚至於一個網站數十或數百個 request 到 server。在 HTTP1.1 時，每一個請求都必須佔用一個連線 (TCP connection)，為了加速網站只好開多個連線併發請求。而在 HTTP2 改善了這一點，差別如下：\n 連線多工 (Multiplexing)，在單一網路連線上，就可以同時傳輸多個 HTTP Request 和 Response，併發請求 CSS/JS/Images 等等資源。它的原理是將 Requests/Responses 都拆碎成小的 frames 進行傳輸，且這些 frames 是可以交錯的，因此檔案再多也不怕，不會發生佔用網路連線 (TCP connection) 的情況。也只需要單一連線就可以處理。 可決定檔案優先順序 Header 壓縮  需要 HTTPS 要先擁有 TLS/SSL 安全性憑證，除了有更快速度，同時也要求了更好的網路安全。\n後記 其實在寫這篇的過程中，好幾度煞不住車，越寫越細，包括各個協定的細節、原理還有延伸出去的技術，甚至於實作的部分，導致於篇幅越來越大，但是怕這篇會變成大雜燴，就只好先簡述個大概了，待以後再補完各個的細節及實作。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/draft/",
	"title": "draft",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/hexo/",
	"title": "hexo",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/hexo-draft/",
	"title": "Hexo 草稿",
	"tags": ["hexo", "draft"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "在寫部落格的時候常常會因為篇幅過大沒辦法一次編寫完成，或是同時編寫多篇文章，這時候就會希望不要把這些文章發佈出去。\n建立草稿 $ hexo new draft \u0026lt;title\u0026gt; Hexo 建立草稿後會產生檔案在 source/_drafts 下，在這目錄之下的文件不會被發佈出去。\n預覽草稿 那若是我想要看看我編輯的文章要怎麼辦呢？Hexo 提供了下面的方法：\n$ hexo server --draft 發佈草稿 $ hexo publish \u0026lt;file\u0026gt; ※ file 不包含副檔名\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/hexo-guide/",
	"title": "Hexo 指南",
	"tags": ["hexo"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "其實目前官網的文件非常詳細，這裡就不多做介紹了。\n安裝 Hexo $ npm install hexo-cli -g 建立 \u0026amp; 初始化 $ hexo init \u0026lt;folder\u0026gt; $ cd \u0026lt;folder\u0026gt; $ npm install 建立後會有以下資料夾 \u0026amp; 檔案\n. ├── _config.yml # 網站設定檔 ├── package.json ├── scaffolds # 鷹架資料夾 ├── scripts # 腳本資料夾 ├── source | ├── _drafts | └── _posts └── themes # 主題 配置 ※ 官方設定檔文件\n常用指令 # 查看幫助 hexo help # 新建文章 hexo new \u0026quot;postName\u0026quot; # 新建頁面 hexo new page \u0026quot;pageName\u0026quot; # 產生靜態網頁 hexo generate # 本機預覽 hexo server # 部署 hexo deploy # 清除暫存，執行前建議使用 hexo clean  簡寫 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy  部署到 Git 透過 Git 發佈，安裝 Git 套件\n$ npm install hexo-deployer-git --save 修改 _config.yml 設定值\n# Deployment deploy: type: git repo: git@github.com:dexiang/dexiang.github.io.git branch: master message: 設定好以後就可以部署了\n$ hexo deploy  GitHub Page\n Domain Name 設定 首先當然要先有 Domain Name 啦～ 設定好以後，可透過 CNAME 設定到部落格上。\n另外在每次 deploy 到 Github 上時，CNAME 會一直被覆蓋，怎麼辦呢？\n安裝 CNAME，在 deploy 時自動產生 CNAME 檔案\n$ npm install hexo-generator-cname --save $ cd source/ $ touch CNAME $ vim CNAME # 輸入domain，EX：dexiang.tw 主題 每一家的 Theme 都有長處，可依個人喜好，以下是以 github 星星數整理出來的排名。\n  NexT  https://github.com/iissnan/hexo-theme-next\n  Yilia  https://github.com/litten/hexo-theme-yilia\n  Tranquilpeak  https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak\n  Yelee  https://github.com/MOxFIVE/hexo-theme-yelee\n  Jacman  https://github.com/wuchong/jacman\n  Maupassant  https://github.com/tufu9441/maupassant-hexo\n  Apollo  https://github.com/pinggod/hexo-theme-apollo\n  Icarus  https://github.com/ppoffice/hexo-theme-icarus\n  Material  https://github.com/viosey/hexo-theme-material\n  Fexo  https://github.com/forsigner/fexo\n 我選用的是 Yilia Theme\n常見問題  修改配置時需注意 YAML 語法，參數冒號後 (:) 一定要留一個空格 所有問題請轉成 UTF-8 格式  "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/hexo-introduction/",
	"title": "Hexo 簡介",
	"tags": ["hexo"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "幾年前因為想寫一些文章而用 wordpress 架設了一網站，但覺得要管理維護太麻煩，後來就改到 Blogger，雖然它的功能很方便，與 google 的產品結合 (GA)，且有 SEO 的優勢，但一方面是想要有更高的控制權，另一方面是想換一個工具試試看。\n什麼是 Hexo Hexo 是一個基於 Node.js 的部落格框架，可透過 Hexo 快速產生一個部落格，只需要幾行指令就可以搞定。安裝環境也是。支援 MarkDown 語法且兼容\n 那什麼又是 Node.js Node.js 是採用 Google V8 引擎來運行 javascript 環境。\n 為何選擇 Hexo  容易安裝，只要安裝好 Node.js \u0026amp; Git，幾行指令就可以安裝完成 方便部署，產生靜態網頁並整合 Git，且編譯速度快，可在 Github 上建立 blog，無限流量，不需建置 Server 用 MarkDwon 來寫文章，讓自已可以專心在文章的內容，而不用去煩惱版面，且任意編輯器都可以拿寫文章 在挑選 Blogger 的過程中，發現不少社群的朋友都選擇這一套，網路的資源也多  準備工作  Node.js Git Xcode (Mac) MarkDown 編輯器 (非必須) Domain Name (非必須)  "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/cloud-server/",
	"title": "雲端主機",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "之前有一大段時間都把服務放在 AWS 的 EC2 上，但最近在整理環境的時候開始思考，以我的需求有需要把服務放在 EC2 上嗎？ 就開始研究相關的服務，查了一些文章及同事的推薦，就想說把這些訊息分享出來。\n虛擬主機 若是有玩過虛擬機的人，例如 VMware、VirtualBox 這些東西，其實原理是一樣的。虛擬主機就像大通舖一樣，一群人要一起共用設施，床位也可能因為旁人的影響而限縮，但優點就是便宜。\nVPS VPS 是 Virtual Private Server 的縮寫，就是在一台機器上以軟體的方式模擬成多台機器，讓這些機器能分享CPU、記憶體、硬碟…等硬體資源，並各自運作不同的程式，不互相干擾。VPS 就像套房一樣，有獨立的衛浴及設施，相對的價格比較高。\n目前 VPS 的技術比較常見的兩種，分別為 Xen 跟 OpenVZ，兩者使用的虛擬技術不太一樣，OpenVZ 的每一台虛擬機的資源由 OpenVZ 動態控制著，共用著所有的 kernel，實體上來說，每一部虛擬機器並不是真的擁有自己的資源 ( CPU、記憶體\u0026hellip;)；而 Xen 則是以模擬硬體的方式，讓每部虛擬機器擁有自己的各種硬體環境，所以，每部虛擬機器是完全獨立的，一旦分到多少的資源，就是多少，不像 OpenVZ 那樣可以動態的調整，因此，採用 XEN 的電腦所能夠分割出來的虛擬機器數量，因為被固定住資源，所以，可能會比較 OpenVZ 來的少。\n主機代管 / 實體主機 其實 VPS 的需求對我來說已經很夠用了，但是若是需要考慮到安全和擴充性可以再往上考慮主機代管或實體主機的方案，這兩個方案可以由自己的需要來擴充設備，不同於 VPS 來說，是真正獨立的資源。若 VPS 是租房，那麼這方案就是買房了，可以完全由自己決定要甚麼樣的建築及結構。\nEC2 VPS 的一種，採用 Xen 技術，與一般的 VPS 不同的是它的彈性很大，有不同的 region 可供選擇，且依照小時來計價，更有彈性。\n另外，在 2016/11/30 Amazon 也開始有平價 VPS 供選擇：Amazon Lightsail，一個月最低 5 美元，第一個月免費。\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/cloud-computing/",
	"title": "雲端服務",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "雲端運算的比喻：對於一名用戶，由提供者提供的服務所代表的網路元素都是看不見的，仿佛被雲端掩蓋。\n軟體即服務 Software as a Service, SaaS 平台即服務 Platform as a Service, PaaS 基礎設施即服務 Infrastructure as a Service, IaaS http://image.slidesharecdn.com/cloud-computing-v261-100301154155-phpapp01/95/presentation-on-effectively-and-securely-using-the-cloud-computing-paradigm-v26-15-728.jpg?cb=1267458215\nhttps://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97\nhttps://www.cloudopenlab.org.tw/ccipo_industryDefinition.do\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/apache/",
	"title": "Apache",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/aws-ec2-lamp-2/",
	"title": "AWS EC2 LAMP (2)",
	"tags": ["AWS", "EC2", "LAMP", "Apache", "PHP", "MySQL"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "上一篇介紹了如何建置 LAMP 環境，這篇要來介紹如何建立一個網頁服務的相關設定\nDomain name 想到網頁當然第一個想到的是網址也就是 Domain name\n我用的是 godaddy，到上面去設定 A Record 就可以了\nApache 設定 若是有需要在一台機器上設定多個網站，那麼就用 virtualhost 吧\nvirtualhost 建立預存放目錄\n1 2  # XXX 表示專案名稱 $ mkdir /var/www/workspace/XXX   修改 Apache 設定\n1  $ vi /etc/httpd/conf/httpd.conf   # XXX 專案 \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin administrator@mail.com ServerName XXX.domain.com ServerAlias domain.com DocumentRoot \u0026quot;/var/www/workspace/XXX\u0026quot; \u0026lt;Directory \u0026quot;/var/www/workspace/XXX\u0026quot;\u0026gt; AllowOverride All Options FollowSymlinks MultiViews Require all granted \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; 重啟 Apache\n1  $ service httpd restart   phpMyAdmin 若是需要由網頁來 access MySQL，phpMyAdmin 不失為一個選擇\n我自己是下載 phpMyAdmin-4.4.11-all-languages.tar.xz\n解壓縮\n1  $ tar -Jxvf phpMyAdmin-4.4.11-all-languages.tar.xz   變更檔名\n1  $ mv phpMyAdmin-4.4.11-all-languages phpMyAdmin   移動檔案\n1  $ cp -r phpMyAdmin /var/www   設定 phpMyAdmin\n1 2  $ cp config.sample.inc.php config.inc.php $ vi config.inc.php   1  $cfg[\u0026#39;Servers\u0026#39;][$i][\u0026#39;auth_type\u0026#39;] = \u0026#39;http\u0026#39;;   修改 Apache 設定\n1  $ vi /etc/httpd/conf/httpd.conf   Alias /phpMyAdmin \u0026quot;/var/www/phpMyAdmin\u0026quot; 重啟 Apache\n1  $ service httpd restart   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/ec2/",
	"title": "EC2",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/lamp/",
	"title": "LAMP",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/tags/mysql/",
	"title": "MySQL",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.dexiang.me/zh-tw/technologies/aws-ec2-lamp-1/",
	"title": "AWS EC2 LAMP (1)",
	"tags": ["AWS", "EC2", "LAMP", "Apache", "PHP", "MySQL"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "使用 Linux 架設 web server，LAMP 是非常常用的選擇，LAMP 代表 Linux + Apache + MySQL + PHP，當然還有很多的組合，像是 LNMP (Linux + Nginx + MySQL + PHP) 等等的搭配，但這篇就先針對 LAMP 做介紹。\n首先這篇採用 EC2 主機搭配作介紹，皆用 yum 安裝。\n在安裝過程中因權限的關係，以下皆是以 root 的身分。\n安裝 LAMP yum 查詢是否有安裝yum\n1  $ rpm -qa | grep yum   更新所有已安裝的套件 (-y 表示安裝更新時不跳確認提示)\n1  $ yum update -y   Apache、PHP、MySQL 安裝 Apache、PHP、MySQL\n1  $ yum install -y httpd24 php56 mysql55-server php56-mysqlnd php56-mbstring   修改 php.ini\n1  $ vi /etc/php.ini   1 2 3 4 5 6  ; PHP tag 簡寫 (應該是要保持關閉的....，但因為有些 legacy code，慚愧...) short_open_tag = On ; 時區 date.timezone = Asia/Taipei ; 最大上傳檔案大小 upload_max_filesize = 50M   啟用服務\n1 2  $ service httpd start $ service mysqld start   設定 mysql 管理者密碼\n1 2 3 4 5  # XXXX 表示密碼 # 設定密碼 $ mysqladmin -u root password \u0026#39;XXXX\u0026#39; # 修改密碼 $ mysqladmin -u root -p password \u0026#39;XXXX\u0026#39;   設定開機時啟用\n1 2  $ chkconfig httpd on $ chkconfig mysqld on   "
},
{
	"uri": "https://blog.dexiang.me/zh-tw/about/",
	"title": "About Me",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "About Me",
	"content": "我是 Tony\n"
},
{
	"uri": "https://blog.dexiang.me/zh-tw/trivia/",
	"title": "MISC",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "雜記測試\n"
}]